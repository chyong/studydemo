1.类加载：
  a. klass模型:
     Java的每个类，在JVM中，都有⼀个对应的Klass类实例与之对应，存储类的元信息如：常量池、属性信息、⽅法信息等，类的元信息是存储在原空间的，普通的Java类在JVM中对应的是instanceKlass类的实例，它的三个⼦类
        1. InstanceMirrorKlass：⽤于表示java.lang.Class，Java代码中获取到的Class对象，实际上就是这个C++类的实例，存储在堆区，学名镜像类。
        2. InstanceRefKlass：⽤于表示java/lang/ref/Reference类的⼦类。
        3. InstanceClassLoaderKlass：⽤于遍历某个加载器加载的类。
     Java中的数组不是静态数据类型，是动态数据类型，即是运⾏期⽣成的，Java数组的元信息⽤ArrayKlass的⼦类来表示：
        1. TypeArrayKlass：⽤于表示基本类型的数组。
        2. ObjArrayKlass：⽤于表示引⽤类型的数组。
  b. 类加载的过程:
     类加载机制分为五个部分：加载，验证，准备，解析，初始化
        1. 加载：加载是类加载过程的第一个阶段，这个阶段主要完成以下三件事：
                1.通过一个类的全限定名来获取其定义的二进制字节流。
                2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
                3.在Java堆中生成一个代表这个类的java.lang.Class对象，即instanceMirrorKlass实例，作为对方法区中这些数据的访问入口。
                注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。
        2. 验证：这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，主要分为四步：⽂件格式验证、元数据验证、字节码验证、符号引⽤验证。
        3. 准备：给类变量（static静态变量）分配内存、赋初值（这里的初值指的是数据类型默认的零值，真正的赋值过程发生在类构造器的<clinit>()方法中），注意这里不是给实例变量赋值，实例变量是在创建实例时进行赋值的，如果
                该变量被final修饰，在编译的时候会给属性添加ConstantValue属性，准备阶段直接完成赋值。
        4. 解析：将常量池中的符号引⽤转为直接引⽤，符号引用是用一组符号来描述目标，可以是任何字面量，而直接引用则是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。举个例子来说明，
                在com.sbbic.Person类中引用了com.sbbic.Animal类，在编译阶段，Person类并不知道Animal的实际内存地址，因此只能用com.sbbic.Animal来代表Animal真实的内存地址。在解析阶段，JVM可以通过解析该符号引用，
                来确定com.sbbic.Animal类的真实内存地址（如果该类未被加载过，则先加载），主要有以下四种：类或接口的解析、字段解析、类方法解析、接口方法解析，何时解析：加载阶段解析常量池时、用的时候。
        5. 初始化：类加载过程的最后一步，到该阶段才真正开始执行类中定义的java代码，同样该阶段也是初始化类变量（完成静态变量的赋值）和其他资源（执行静态字段和静态代码块），换句话说该阶段是执行类构造器<clinit>()方法的过程。
                 <clinit>()方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕（父类的静态语句块和静态变量优先于子类中变量赋值操作），
                 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<clinit>()方法。
  c. 类加载器：把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作交给虚拟机之外的类加载器来完成。这样的好处在于，我们可以自行实现类加载器来加载其他格式的类，只要是二进制字节流就行，这就大大增强了加载器灵活性。
        1. 启动类加载器(Bootstrap ClassLoader)：
               由C/C++实现，负责加载<JAVA_HOME>\jre\lib目录下或者是-Xbootclasspath所指定路径下目录以及系统属性sun.boot.class.path制定的目录中特定名称的jar包到虚拟机内存中。
               在JVM启动时，通过Bootstrap ClassLoader加载rt.jar，并初始化sun.misc.Launcher从而创建Extension ClassLoader和Application ClassLoader的实例。需要注意的是，Bootstrap ClassLoader只会加载特定名称的类库，
               比如rt.jar，这意味我们自定义的jar扔到<JAVA_HOME>\jre\lib也不会被加载。
        2. 扩展类加载器（Extension Classloader）：
               只有一个实例，由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>\lib\ext目录下或是被系统属性java.ext.dirs所指定路径目录下的所有类库。
        3. 应用程序类加载器(Application ClassLoader)：
               只有一个实例，由sun.misc.Launcher$AppClassLoader实现，负责加载系统环境变量ClassPath或者系统属性java.class.path指定目录下的所有类库，
               如果应用程序中没有定义自己的加载器，则该加载器也就是默认的类加载器。该加载器可以通过java.lang.ClassLoader.getSystemClassLoader获取。
        4. 自定义类加载器：
               1. 遵守双亲委派模型：继承ClassLoader，重写findClass()方法。
               2. 破坏双亲委派模型：继承ClassLoader，重写loadClass()方法。
        5. 线程上下文类加载器(Thread Context ClassLoader)：
               每个线程都有一个类加载器(jdk 1.2后引入)，称之为Thread Context ClassLoader，如果线程创建时没有设置，则默认从父线程中继承一个，如果在应用全局内都没有设置，
               则所有Thread Context ClassLoader为Application ClassLoader。可通过Thread.currentThread().setContextClassLoader(ClassLoader)来设置，通过Thread.currentThread().getContextClassLoader()来获取。
               该类加载器容许父类加载器通过子类加载器加载所需要的类库，也就是打破了双亲委派模型。
        6. 双亲委派模型：
               如果⼀个类加载器收到了加载某个类的请求，则该类加载器并不会去加载该类，⽽是把这个请求委派给⽗类加载器，每⼀个层次的类加载器都是如此，因此所有的类加载请求最终都会传送到顶端的启动类加载器。
               只有当⽗类加载器在其搜索范围内⽆法找到所需的类，并将该结果反馈给⼦类加载器，⼦类加载器会尝试去⾃⼰加载。这样的好处有：
               1. 可以避免重复加载，父类已经加载了，子类就不需要再次加载。
               2. 更加安全，很好的解决了各个类加载器的基础类的统一问题，如果不使用该种方式，那么用户可以随意定义类加载器来加载核心api，会带来相关隐患。
        7. 类加载器的特点：
               运行任何一个程序时，总是由Application Loader开始加载指定的类。一个类在收到加载类请求时，总是先交给其父类尝试加载。Bootstrap Loader是最顶级的类加载器，其父加载器为null。
        8. 类加载的三种方式：
               1. 通过命令行启动应用时由JVM初始化加载含有main()方法的主类。
               2. 通过Class.forName()方法动态加载，会默认执行初始化块（static{}），但是Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。
               3. 通过ClassLoader.loadClass()方法动态加载，不会执行初始化块。
        9. 打破双亲委派：
               因为在某些情况下⽗类加载器需要委托⼦类加载器去加载class⽂件。受到加载范围的限制，⽗类加载器⽆法加载到需要的⽂件，以Driver接⼝为例，由于Driver接⼝定义在jdk当中的，⽽其实现由各个数据库的
               服务商来提供，⽐如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接⼝的实现类，然后进⾏管理，但是DriverManager由启动类加载器加载，只
               能记载JAVA_HOME的lib下⽂件，⽽其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托⼦类来加载Driver实现，从⽽破坏了双亲委派。
               打破双亲委派的意思其实就是不委派、向下委派，例如：
               1. ⾃定义类加载器，继承ClassLoader，重写loadClass()方法。
               2. SPI：是⼀种服务发现机制。它通过在ClassPath路径下的META-INF/services⽂件夹查找⽂件，⾃动加载⽂件⾥所定义的类。这⼀机制为很多框架扩展提供了可能，⽐如在Dubbo、JDBC中都使⽤到了SPI机制。
        10. 沙箱安全：
               跟Linux的权限机制有点像，⽐如我定义了⼀个类名为String所在包为java.lang，因为这个类本来是属于jdk的，如果没有沙箱安全机制的话，这个类将会污染到我所有的String，但是由于沙箱安全机制，
               所以就委托顶层的bootstrap加载器查找这个类，如果没有的话就委托extsion，extsion没有就到appclassloader，但是由于String就是jdk的源代码，所以在bootstrap那⾥就加载到了，先找到先使⽤，
               所以就使⽤bootstrap⾥⾯的String，后⾯的⼀概不能使⽤，这就保证了不被恶意代码污染。
2.字节码文件：即.class文件，是Java编译器编译Java源文件（.java）产生的，它是一种8位字节的二进制流文件，各个数据项按顺序紧密的从前向后排列，相邻的项之间没有间隙，这样可以使得class文件非常紧凑，
            体积轻巧，可以被JVM快速的加载至内存，并且占据较少的内存空间（方便于网络的传输）。
        a. 字节码文件的结构：
               magic：魔数，class文件的标志，他是一个固定的值：0XCAFEBABE。如果开头四个字节不是0XCAFEBABE，那么就说明它不是class文件，不能被JVM识别，占4字节。
               minor version 和 major version：次版本号和主版本号，高版本的JVM能识别低版本的javac编译器编译的class文件，而低版本的JVM不能识别高版本的javac编译器编译的class文件，各占2字节。
               constant pool count：常量池数量，占2字节。
               constant pool：存放编译器⽣成的各种字⾯量(Literal)和符号引⽤(Symbolic References)，字⾯量包括：1.⽂本字符串 2.⼋种基本类型的值 3.被声明为final的常量等;符号引⽤包括：1.类和接口的全限定名
                              2.字段的名称和描述符 3.⽅法的名称和描述符。
               access flag：当前类的访问权限，占2字节。
               this class：当前类的全限定名在常量池里的索引（类名），占2字节。
               super class：当前类的父类的全限定名在常量池里的索引（父类名），占2字节。
               interfaces count：当前类实现的接口数量，占2字节。
               interfaces[]：包含interfaces count个接口的全局限定名（实现的接口名）的索引的数组。
               fields count：类变量和实例变量的字段的数量总和（类成员的总个数），占2字节。
               fields[]：包含字段详细信息的列表（类成员详情数组）。
               methods count：该类或者接口显示定义的方法的数量，占2字节。
               method[]：包含方法信息的一个详细列表。
               attributes count：该类或者接口所定义的属性信息（attributes info）的数量，占2字节。
               attributes[]：该类或者接口所定义的属性信息，属性可以出现在class文件的很多地方，而不只是出现在attributes列表里。如果是attributes表里的属性，那么它就是对整个class文件所对应的类或者接口的描述；
                             如果出现在fields的某一项里，那么它就是对该字段额外信息的描述；如果出现在methods的某一项里，那么它就是对该方法额外信息的描述。
3.内存池与JVM内存模型：JVM内存模型其实就是JVM在启动的时候从操作系统内存中要了⼀块⼤内存，然后将这个⼤内存分成五个区域：⽅法区、堆区、虚拟机栈、本地⽅法栈、程序计数器。注意区分JVM内存模型与JMM（Java Memory Model）。
        a. 方法区：jdk1.7之前方法区的实现叫永久代，永久代和堆相互隔离，永久代的⼤⼩在启动JVM时可以设置⼀个固定值，不可变（很有可能导致永久代内存溢出），jdk1.7中存储在永久代的部分数据就已经转移到了java堆或者是
                  native堆（调用本地方法-c方法时s申请的内存空间）。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native堆；字面量(interned strings-串池)转移到了java堆；
                  类的静态变量(class statics)转移到了java堆。
                  jdk1.8取消了永久代，此时方法区的实现叫元空间，元空间本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。
                  因此默认情况下元空间的大小仅受本地内存限制。
                  方法区存放着类的版本、字段、方法、接口和常量池（存储字面量和符号引用）。
        b. 堆区：是被线程共享的一块内存区域，存放创建的实例对象以及数组，也是垃圾收集器进行垃圾收集的最重要的内存区域，JVM调优重点关注的区域，由于现代VM采用分代收集算法, 因此Java堆从GC的角度还可以
                细分为：新生代(Eden区、From Survivor区和To Survivor区)和老年代。
                异常：OutOfMemoryError
        c. 虚拟机栈：是描述java方法执行的内存模型，基于栈运⾏，每个方法在执行的同时都会创建一个栈帧（Stack Frame）。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
                   栈帧（Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、方法返回值和异常分派（Dispatch Exception）。栈帧随着方法调用而创建，
                   随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。
                   栈帧（Frame）中存储了局部变量表、操作数栈、动态链接（部分符号引用在每一次运行时期转化为直接引用的过程称为动态链接）、返回地址、附加信息等几个区域。
                   异常：StackOverflowError、OutOfMemoryError
        d. 本地⽅法栈：本地方法栈主要为Native方法服务，java通过jni调⽤C、C++动态链接库需要的栈，随着socket的发展，jni技术已经⽤得⾮常⾮常少。异常：StackOverflowError、OutOfMemoryError
        e. 程序计数器：一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，即字节码指令前⾯的index，正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是Native方法，则为空。
                     这个内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError情况的区域。
        f. 之间的关系：
              虚拟机栈与⽅法区：如何理解虚拟机栈⽅法区的引⽤-动态链接。
              虚拟机栈与堆区：如何理解虚拟机栈对堆区的引⽤-局部变量。
                  Test obj = new Test();
                  Class对象
                  instanceKlass 类的元信息
              ⽅法区与堆区：如何理解⽅法区与堆区的双向引⽤：
                  ⽅法区->堆区：引⽤类型的静态属性。
                  堆区->⽅法区：klass pointer 指向该对象的instanceKlass实例。
4.字符串常量池：jdk1.7以前位于方法区（永久代），jdk1.7及以后移到了堆区。
        a. 直接赋值字符串：String s ="11";// s指向字符串常量池中的引用
              创建该对象的时候，jvm会先去字符串常量池中通过equals(key)方法，判断是否有相同的对象，如果有，则直接返回该对象在字符串常量池中的引用。如果没有，则会在字符串常量池中创建一个新对象，再返回其引用。
              这种方式创建的字符串对象，只会在字符串常量池中。
        b. new String()：String s1 =newString("11");// s1指向内存（堆）中的对象
              创建该对象的时候，jvm会先检查字符串常量池中是否存在字符串"11"，不存在，先在字符串常量池里创建一个字符串对象，再去堆中创建一个字符串对象"11"，存在的话，就直接去堆内存中创建一个字符串对象"11"，最后将堆中的引用返回。
              这种方式会保证字符串常量池和堆中都有这个对象，没有就创建，最后返回堆内存中的对象引用。
        c. intern方法：String中的intern方法是一个native的方法，当调用intern方法时，如果字符串常量池已经包含一个等于该String对象的字符串（用equals(oject)方法确定），则返回字符串常量池中该字符串的引用。
              如果字符串常量池中不包含等于该String对象的字符串，则将该字符串放入字符串常量池中并返回其引用（jdk1.7及以后）。
              注：jdk1.7及以后调用intern方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象（jdk1.7及以前）。
5.执⾏引擎、jit(即时编译)、逃逸分析：
        a. 执⾏引擎、jit(即时编译)：
              java是半编译半解释型语⾔：1.javac编译，java运⾏ 2.运⾏期即时编译 + 解释执⾏
              jvm中两种解释器：
                  1.字节码解释器 做的事情是：java字节码->c++代码->硬编码
                  2.模板解释器 做的事情：java字节码->硬编码
                  三种运⾏模式：
                      -Xint：纯字节码解释器模式（程序简单）
                      -Xcomp：纯模板解释器模式（程序复杂）
                      -Xmixed：字节码解释器 + 模板解释器模式（默认）
              两种即时编译器：jdk1.6以前是没有混合编译的，后来根据两种编译器的使⽤场景组合起来使⽤进⼀步提升性能。
                 1.C1编译器：
                     -client模式启动，默认启动的是C1编译器。有哪些特点呢？
                     1.需要收集的数据较少，即达到触发即时编译的条件较宽松
                     2.⾃带的编译优化优化的点较少
                     3.编译时较C2，没那么耗CPU，带来的结果是编译后⽣成的代码执⾏效率较C2低
                 2.C2编译器：
                     -server模式启动。有哪些特点呢？
                     1.需要收集的数据较多
                     2.编译时很耗CPU
                     3.编译优化的点较多
                     4.编译⽣成的代码执⾏效率⾼
                 3.混合编译：
                     ⽬前都是-server模式启动，已经不是纯粹只使⽤C2。程序运⾏初期因为产⽣的数据较少，这时候执⾏C1编译，程序执⾏⼀段时间后，收集到⾜够的数据，执⾏C2编译器
              即时编译触发条件：
                 ⽬前的64bit机器上只有-server模式。⼤家现在谈执⾏引擎，说的都是-server模式启动的jvm中的执⾏引擎
                 触发即时编译的最⼩单位是代码段，最⼤单位是⽅法
                 Client 编译器模式下，N 默认的值 1500
                 Server 编译器模式下，N 默认的值则是 10000
              热点代码缓存区：
                 热点代码缓存是保存在⽅法区的，这块也是调优需要调的地⽅
                 server 编译器模式下代码缓存⼤⼩则起始于 2496KB
                 client 编译器模式下代码缓存⼤⼩起始于 160KB
                 java -XX:+PrintFlagsFinal -version | grep InitialCodeCacheSize
        b. 逃逸分析：
              在编译程序优化理论中，逃逸分析是⼀种确定指针动态范围的⽅法——分析在程序的哪些地⽅可以访问到指针。它涉及到指针分析和形状分析。java的逃逸分析只发在JIT的即时编译中，因为收集到⾜够的运⾏数据JVM可以更好的判断
              对象是否发⽣了逃逸。
              jvm判断新创建的对象是否逃逸的依据有：⼀、对象被赋值给堆中对象的字段和类的静态变量。⼆、对象被传进了不确定的代码中去运⾏。如果满⾜了以上情况的任意⼀种，那这个对象jvm就会判定为逃逸。
              对于第⼀种情况，因为对象被放进堆中，则其它线程就可以对其进⾏访问，所以对象的使⽤情况，编译器就⽆法再进⾏追踪。第⼆种情况相当于jvm在解析普通的字节码的时候，如果没有发⽣jit即时编译，
              编译器是不能事先完整知道这段代码会对对象做什么操作。保守⼀点，这个时候也只能把对象是当作是逃逸来处理.
              基于逃逸分析的优化：
                 当判断出对象不发⽣逃逸时，编译器可以使⽤逃逸分析的结果作⼀些代码优化。
                 1.将堆分配转化为栈分配。如果某个对象在⼦程序中被分配，并且指向该对象的指针永远不会逃逸，该对象就可以在分配在栈上，⽽不是在堆上。在有垃圾收集的语⾔中，这种优化可以降低垃圾收集器运⾏的频率。
                   说明：⽅法栈上的对象在⽅法执⾏完之后，栈桢弹出，对象就会⾃动回收。这样的话就不需要等内存满时再触发内存回收。这样的好处是程序内存回收效率⾼，并且GC频率也会减少，程序的性能就提⾼了。
                 2.同步消除。如果发现某个对象只能从⼀个线程可访问，那么在这个对象上的操作可以不需要同步。
                   说明：如果发现某个对象只能从⼀个线程可访问，那么在这个对象上的操作可以不需要同步。逃逸分析把锁消除了，并在性能上得到了很⼤的提升。这⾥说明⼀下java的逃逸分析是⽅法级别的，因为jit的即时编译是⽅法级别。
                 3.分离对象或标量替换。如果某个对象的访问⽅式不要求该对象是⼀个连续的内存结构，那么对象的部分（或全部）可以不存储在内存，⽽是存储在CPU寄存器中。
                   说明：这个简单来说就是把对象分解成⼀个个基本类型，并且内存分配不再是分配在堆上，⽽是分配在栈上。这样的好处有，⼀、减少内存使⽤，因为不⽤⽣成对象头。 ⼆、程序内存回收效率⾼，并且GC频率也会减少，
                        总的来说和上⾯优点⼀的效果差不多。
              虚拟机配置参数：
              -XX:+PrintGC -Xms5M -Xmn5M -XX:+DoEscapeAnalysis
                  -XX:+DoEscapeAnalysis表示开启逃逸分析，jdk1.8是默认开启的，-DoEscapeAnalysis表示关闭逃逸分析
                  -XX:+PrintGC 表示打印GC信息 -PrintGC 表示不打印GC信息
                  -Xms5M -Xmn5M 设置jvm内存⼤⼩是5M
6.垃圾回收算法：
       a. 垃圾判断算法：
             1. 引用计数算法：在对象中添加⼀个属性⽤于标记该对象被引⽤的次数，每多⼀次被其他对象引⽤，计数+1，当引⽤失效时，计数-1，如果计数=0，表示没有被其他对象引⽤，就可以被回收。
                           这个算法⽆法解决循环引⽤的问题（A引用B，B又引用A，形成一个死循环，导致这两个对象一直不能被回收）。
             2. 可达性分析算法：通过一系列被称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系链向下搜索，如果某个对象无法被搜索到，则说明该对象无引用关系，也就是这个对象不可达，
                             不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收（详见下面三色标记）。
                补充：
                    java中可以作为GC Roots的对象：
                        虚拟机栈（栈帧中的局部变量表）中引用的对象
                        方法区中类静态属性引用的对象
                        方法区中常量引用的对象
                        本地方法栈中JNI（即一般说的native方法）中引用的对象
       b. 垃圾回收算法：
             1. 标记清除算法（Mark-Sweep）：最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。
                                        缺点：如果要标记的对象太多，效率低，内存碎片化严重。
             2. 复制算法（copying）：针对标记清除算法内存碎片化严重的问题提出的算法，将内存分为等大小的两块，每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。
                                   优点：实现简单，内存效率高，不易产生碎片。缺点：可用内存被压缩到了原本的一半，且存活对象增多的话，Copying算法的效率会大大降低。
             3. 标记整理算法(Mark-Compact)：结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清理对象，而是将存活对象移向内存的一端，然后清除端边界外的对象。
             4. 分代收集算法：分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老年代(2/3，Tenured/Old Generation)和新生代(1/3，Young Generation)。
                           老年代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。
                    a. 新生代与复制算法：目前大部分JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。
                                      一般将新生代划分为一块较大的Eden空间（4/5）和两个较小的Survivor空间（各1/10）(From Space, To Space)，每次使用Eden空间和其中的一块Survivor空间，
                                      当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中。
                    b. 老年代与标记整理算法：老年代因为每次只回收少量对象，因而采用Mark-Compact算法。
                     注：1. JAVA虚拟机提到过的处于方法区的永久代(Permanet Generation)，它用来存储class类，常量，方法描述等。对永久代的回收主要包括废弃常量和无用的类。
                        2. 对象的内存分配主要在新生代的Eden Space和Survivor Space的From Space(Survivor目前存放对象的那一块)，少数情况会直接分配到老年代。
                        3. 当新生代的Eden Space和From Space空间不足时就会发生一次GC，进行GC后，Eden Space和From Space区的存活对象会被挪到To Space，然后将Eden Space和From Space进行清理。
                        4. 如果To Space无法足够存储某个对象，则将这个对象存储到老年代。
                        5. 在进行GC后，使用的便是Eden Space和To Space了，如此反复循环。
                        6. 当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被移到老年代中。
       c. 三⾊标记与读写屏障：现在主流的垃圾收集器都⽀持并发标记。什么是并发标记呢？就是标记的时候不暂停或少暂停⽤户线程，这时对象间的引用可能发生变化，势必会带来三个问题：多标、少标、漏标。
                          垃圾收集器是如何解决这个问题的呢：三⾊标记+读写屏障。
             1. 三色标记：即把GC Roots可达性分析遍历对象过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色：
                        a. 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经访问过。黑色的对象代表已经访问过，它是安全存活的，如果有其他对象引用指向了黑色对象，
                                无须重新访问一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
                        b. 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被访问过。
                        c. 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
             2. 读写屏障：有点像Spring的AOP。
                        a. 读屏障：即在读前增加屏障做点事情
                                  读屏障()
                                  读操作
                        b. 写屏障：即在写的前后增加屏障做点事情
                                  写前屏障()
                                  写操作
                                  写后屏障()
             3. 详解三个问题：
                        a. 多标-浮动垃圾：在并发标记过程中，如果由于方法运行尚未结束导致部分局部变量(gc root)被销毁，这个gc root引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。
                                       这部分本应该回收但是没有回收到的内存，被称之为浮动垃圾。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被回收。
                        b. 少标-浮动垃圾：并发标记开始后创建的对象，都视为⿊⾊，本轮GC不清除。这部分对象使用完后也会变成垃圾，成为浮动垃圾的一部分。
                        c. 漏标-程序出错：本来应该被标记的对象没有被标记，导致该对象在垃圾回收时被回收了，但该对象还存在引用关系，从而导致程序运行出错。
                                       产生原因：1.灰⾊对象删除了对⽩⾊对象的引⽤，即灰⾊对象原来成员变量的引⽤发⽣了变化。2.⿊⾊对象重新引⽤了该⽩⾊对象，即⿊⾊对象成员变量增加了新的引⽤。
                                       解决办法：
                                          1.写屏障+增量更新（IU，Incremental Update）：也是CMS收集器解决方式
                                               当黑色对象建立新的指向白色对象的引用关系时，就将这个新建立的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。
                                               这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。
                                          2.写屏障+原始快照（SATB，Snapshot At The Beginning）：也是G1收集器解决方式
                                               当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次，
                                               这样就能扫描到白色的对象，将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)。
7.强软弱虚引⽤与垃圾收集器：
      a. 强软弱虚引⽤：
            1.强引用：我们平时写的代码如 Test obj = new Test()；这种引用关系就是强引用，垃圾回收器将永远不会回收被强引用的对象，就算会OOM也不会回收，因此强引用是造成Java内存泄漏的主要原因之一。
            2.软引用：SoftReference类实现，内存不足的情况下才会回收，如果发生了gc但是内存充足，依然不会回收。
            3.弱引用：WeakReference类实现，只要发生gc就会回收。
            4.虚引用：PhantomReference类实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。
      b. GC中的串⾏、并⾏、并发：
            串⾏：⼀个GC线程运⾏。
            并⾏：多个GC线程同时运⾏。
            并发：多个GC线程与多个⽤户线程同时运⾏。
      c. STW：Stop The World，即GC线程与⽤户线程⽆法并发运⾏，GC线程执⾏期间需要暂停⽤户线程。
      d. 垃圾收集器：⽬前JVM中的收集器有九种，了解5个，详解2个。因为并发、分区管理式的收集器才是未来的趋势。没有最好的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。
                   注意：标记阶段标记的是存活对象，回收未被标记的对象。
            1. Serial收集器（单线程、复制算法）：串⾏（单线程）垃圾收集器，即GC线程与⽤户线程先后运⾏，即GC时需要STW（暂停所有⽤户线程），直⾄GC结束才恢复⽤户线程的运⾏，专注于收集年轻代，底层是复制算法。
                                            没有线程交互的开销，可以获得最高的单线程垃圾收集效率，是java虚拟机运行在Client模式下默认的新生代垃圾收集器。
                                            相关参数：-XX:+UseSerialGC
            2. ParNew垃圾收集器（Serial+多线程）：是Serial收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和Serial收集器完全一样。唯⼀能与CMS收集器搭配使⽤的新⽣代收集器。
                                              是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器。
                                              相关参数：-XX:+UseConcMarkSweepGC：指定使⽤CMS后，会默认使⽤ParNew作为新⽣代收集器
                                                      -XX:+UseParNewGC：强制指定使⽤ParNew
                                                      -XX:ParallelGCThreads：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同
            3. Parallel Scavenge收集器（多线程复制算法、高效）：也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是吞吐量，高吞吐量可以最高效率地利用CPU时间，尽快地完成程序的运算任务，
                                                          主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。
                                                          吞吐量：Thoughput，CPU用于运行用户代码的时间/CPU总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)
                                                          GC时也需要STW（暂停所有⽤户线程）
                                                          相关参数：
                                                              -XX:MaxGCPauseMillis：是⼀个⼤于0的毫秒数，收集器将尽⼒保证内存回收花费的时间不超过设定
                                                                  值。不过⼤家不要异想天开地认为如果把这个参数的值设置得稍⼩⼀点就能使得系统的垃圾收集速
                                                                  度变得更快，GC停顿时间缩短是以牺牲吞吐量和新⽣代空间来换取的。停顿时间的确在下降，但吞吐
                                                                  量也降下来了。
                                                              -XX:GCTimeRatio：⼀个⼤于0⼩于100的整数，也就是垃圾收集时间占总时间的⽐率。假设该参数的值设为n，
                                                                  那么系统将花费不超过1/(1+n)的时间用于垃圾收集。
                                                              -XX:+UseAdaptiveSizePolicy：⼀个开关参数，当这个参数打开之后，就不需要⼿⼯指定新⽣代的⼤
                                                                  ⼩（-Xmn）、Eden与Survivor区的⽐例（-XX:SurvivorRatio）、晋升⽼年代对象年龄（-
                                                                  XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运⾏情况收集性能监控信息，
                                                                  动态调整这些参数以提供最合适的停顿时间或最⼤的吞吐量，这种调节⽅式称为GC⾃适应的调节策
                                                                  略（GC Ergonomics）。
            4. Serial Old收集器（单线程标记整理算法）：是Serial垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的java虚拟机默认的年老代垃圾收集器。
                                                 GC时需要STW（暂停所有⽤户线程），有两个用途：1.与Serial、ParNew、Parallel Scavenge收集器搭配使用 2.作为CMS收集器的后备方案。
            5. Parallel Old收集器（多线程标记整理算法）：是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法在JDK1.6才开始提供。在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配老年代的Serial Old收集器，
                                                   只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，
                                                   可以优先考虑新生代Parallel Scavenge和老年代Parallel Old收集器的搭配策略。
            6. CMS收集器（多线程标记清除算法）：是一种老年代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间（低延迟），和其他老年代使用标记-整理算法不同，它使用多线程的标记-清除算法。
                                          最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。由于CMS收集器是并发收集器，即在运行阶段用户线程依然在运行，会产生对象，所以CMS收集器不能等到老年代满了才触发，
                                          而是要提前触发，这个阈值是92%。这个阈值可以通过参数-XX:CMSInitiatingOccupancyFraction设置。
                                          相关参数：
                                              -XX：+UseConcMarkSweepGC：手动开启CMS收集器
                                              -XX:+CMSIncrementalMode：设置为增量模式
                                              -XX:CMSFullGCsBeforeCompaction：设定进行多少次CMS垃圾回收后，进行一次内存压缩
                                              -XX:+CMSClassUnloadingEnabled：允许对类元数据进行回收
                                              -XX:UseCMSInitiatingOccupancyOnly：表示只在到达阀值的时候，才进行CMS回收
                                              -XX:CMSInitiatingOccupancyFraction：设置CMS收集器在老年代空间被使用多少后触发
                                              -XX:+UseCMSCompactAtFullCollection：设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理
                                          CMS收集器工作分四个步骤：
                                              1.初始标记：会STW，只标记GC Roots直接关联的对象。
                                              2.并发标记：不会STW，GC线程与用户线程并发运行。会沿着GC Roots直接关联的对象链遍历整个对象图。可想而知需要的时间较长，但因为是与用户线程并发运行的，
                                                        除了能感知到CPU飙升，不会出现卡顿现象。
                                              3.重新标记：会STW，CMS垃圾收集器通过写屏障+增量更新记录了并发标记阶段新建立的引用关系，重新标记就是去遍历这个记录。
                                              4.并发清除：GC线程与用户线程并发运行，清理未被标记到的对象，默认启动的回收线程数 = (处理器核心数 + 3) / 4。
                                          由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。
                                          缺点：1.运行期间会与用户线程抢夺CPU资源。当然，这是所有并发收集器的缺点。
                                               2.无法处理浮动垃圾（标记结束后创建的对象）。
                                               3.内存碎片。
            7. G1收集器：是目前垃圾收集器理论发展的最前沿成果，能独立管理整个GC堆（新生代和老年代），相比与CMS收集器，G1收集器两个最突出的改进是：1.基于标记-整理算法，不产生内存碎片。2.可以非常精确控制停顿时间，
                       在不牺牲吞吐量前提下，实现低停顿垃圾回收。G1收集器避免全区域垃圾收集，它将堆分成了⼀个⼀个大小相等的region，这些region⽤的时候才被赋予⻆⾊：eden、survivor、to、humongous。
                       ⼀个region只能是⼀个⻆⾊，不存在⼀个region既是eden⼜是survivor。每个region的⼤⼩可通过参数-XX:G1HeapRegionSize设置，取值范围是2-32M。⼀个对象的⼤⼩超过region的⼀半则被认定为⼤对象，
                       会⽤N个连续的region来存储。
                       G1名字的由来：
                           回收某个region的价值⼤⼩ = 回收获得的空间⼤⼩ + 回收所需时间
                           G1收集器会维护⼀个优先级列表，每个region按价值⼤⼩排序存放在这个优先级列表中。收集时优先收集价值更⼤的region，这就是G1名字的由来。
                       G1收集器工作分四个步骤：
                           1.初始标记：会STW，做了两件事：
                                a.修改TAMS（每个region记录着两个top-at-mark-start（TAMS）指针，分别为prevTAMS和nextTAMS）的值，TAMS以上的值为新创建的对象，默认标记为存活对象，即多标。
                                b.标记GC Roots能直接关联到的对象。
                           2.并发标记：耗时较⻓，GC线程与⽤户线程并发运⾏，从GC roots能直接关联到的对象开始遍历整个对象图。
                           3.最终标记：遍历写屏障+SATB记录下的旧的引⽤对象图，会STW。
                           4.筛选回收：更新region的统计数据，对各个region的回收价值进⾏计算并排序，然后根据⽤户设置的期望暂停时间的期望值⽣成回收集。然后开始执⾏清除操作，将旧的region中的存活对象移动到新的region中，
                                     清理这个旧的region，这个阶段需要STW。
                       相关参数：
                           -XX:G1HeapRegionSize：设置region的⼤⼩
                           -XX:MaxGCPauseMillis：设置GC回收时允许的最⼤停顿时间（默认200ms）
                           -XX:+UseG1GC：开启g1
                           -XX:ConcGCThreads：设置并发标记、并发整理的gc线程数
                           -XX:ParallelGCThreads：STW期间并⾏执⾏的gc线程数
                       缺点：1.需要10%-20%的内存来存储G1收集器运⾏需要的数据，如布置RSet（Remember Set记忆集）、CSet（Collection Set回收集）、卡表等。
                            2.运⾏期间会与⽤户线程抢夺CPU资源。当然，这是所有并发收集器的缺点。
            8. 查看默认收集器：java -XX:+PrintFlagsFinal -version | grep GC
            9. 记忆集与卡表：在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。为此，在新生代可以引入记忆集（Remember Set）的数据结构（记录从非收集区到收集区的指针集合），
                          避免把整个老年代加入GCRoots扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（Partial GC）行为的垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，
                          都会面临相同的问题。垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。hotspot使用一种叫做“卡表”(cardtable)的方式实现记忆集，
                          也是目前最常用的一种方式。关于卡表与记忆集的关系，可以类比为Java语言中HashMap与Map的关系。卡表是使用一个字节数组实现：CARD_TABLE[]，每个元素对应着其标识的内存区域一块特定大小的内存块，
                          称为“卡页”。hotSpot使用的卡页是2^9大小，即512字节，一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0。GC时，
                          只要筛选本收集区的卡表中变脏的元素加入GCRoots里。卡表的维护、卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。Hotspot使用写屏障维护卡表状态。
8.jvm调优及实战：详见pdf文件






