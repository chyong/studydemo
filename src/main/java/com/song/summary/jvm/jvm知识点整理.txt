1.类加载：
  a. klass模型:
     Java的每个类，在JVM中，都有⼀个对应的Klass类实例与之对应，存储类的元信息如：常量池、属性信息、⽅法信息等，类的元信息是存储在原空间的，普通的Java类在JVM中对应的是instanceKlass类的实例，它的三个⼦类
        1. InstanceMirrorKlass：⽤于表示java.lang.Class，Java代码中获取到的Class对象，实际上就是这个C++类的实例，存储在堆区，学名镜像类。
        2. InstanceRefKlass：⽤于表示java/lang/ref/Reference类的⼦类。
        3. InstanceClassLoaderKlass：⽤于遍历某个加载器加载的类。
     Java中的数组不是静态数据类型，是动态数据类型，即是运⾏期⽣成的，Java数组的元信息⽤ArrayKlass的⼦类来表示：
        1. TypeArrayKlass：⽤于表示基本类型的数组。
        2. ObjArrayKlass：⽤于表示引⽤类型的数组。
  b. 类加载的过程:
     类加载机制分为五个部分：加载，验证，准备，解析，初始化
        1. 加载：加载是类加载过程的第一个阶段，这个阶段主要完成以下三件事：
                1. 通过一个类的全限定名来获取其定义的二进制字节流。
                2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，即instanceKlass实例。
                3. 在Java堆中生成一个代表这个类的java.lang.Class对象，即instanceMirrorKlass实例，作为对方法区中这些数据的访问入口。
                注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。
        2. 验证：这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，主要分为四步：⽂件格式验证、元数据验证、字节码验证、符号引⽤验证。
        3. 准备：给类变量（static静态变量）分配内存、赋初值（这里的初值指的是数据类型默认的零值，真正的赋值过程发生在类构造器的<clinit>()方法中），注意这里不是给实例变量赋值，实例变量是在创建实例时进行赋值的，如果
                该变量被final修饰，在编译的时候会给属性添加ConstantValue属性，准备阶段直接完成赋值。
        4. 解析：将常量池中的符号引⽤转为直接引⽤，符号引用是用一组符号来描述目标，可以是任何字面量，而直接引用则是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。举个例子来说明，
                在com.sbbic.Person类中引用了com.sbbic.Animal类，在编译阶段，Person类并不知道Animal的实际内存地址，因此只能用com.sbbic.Animal来代表Animal真实的内存地址。在解析阶段，JVM可以通过解析该符号引用，
                来确定com.sbbic.Animal类的真实内存地址（如果该类未被加载过，则先加载），主要有以下四种：类或接口的解析、字段解析、类方法解析、接口方法解析，何时解析：加载阶段解析常量池时、用的时候。
        5. 初始化：类加载过程的最后一步，到该阶段才真正开始执行类中定义的java代码，同样该阶段也是初始化类变量（完成静态变量的赋值）和其他资源（执行静态字段和静态代码块），换句话说该阶段是执行类构造器<clinit>()方法的过程。
                 <clinit>()方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕（父类的静态语句块和静态变量优先于子类中变量赋值操作），
                 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<clinit>()方法。
  c. 类加载器：把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作交给虚拟机之外的类加载器来完成。这样的好处在于，我们可以自行实现类加载器来加载其他格式的类，只要是二进制字节流就行，这就大大增强了加载器灵活性。
        1. 启动类加载器(Bootstrap ClassLoader)：
               由C/C++实现，负责加载<JAVA_HOME>\jre\lib目录下或者是-Xbootclasspath所指定路径下目录以及系统属性sun.boot.class.path制定的目录中特定名称的jar包到虚拟机内存中。
               在JVM启动时，通过Bootstrap ClassLoader加载rt.jar，并初始化sun.misc.Launcher从而创建Extension ClassLoader和Application ClassLoader的实例。需要注意的是，Bootstrap ClassLoader只会加载特定名称的类库，
               比如rt.jar，这意味我们自定义的jar扔到<JAVA_HOME>\jre\lib也不会被加载。
        2. 扩展类加载器（Extension Classloader）：
               只有一个实例，由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>\lib\ext目录下或是被系统属性java.ext.dirs所指定路径目录下的所有类库。
        3. 应用程序类加载器(Application ClassLoader)：
               只有一个实例，由sun.misc.Launcher$AppClassLoader实现，负责加载系统环境变量ClassPath或者系统属性java.class.path指定目录下的所有类库，
               如果应用程序中没有定义自己的加载器，则该加载器也就是默认的类加载器。该加载器可以通过java.lang.ClassLoader.getSystemClassLoader获取。
        4. 自定义类加载器：
               1. 遵守双亲委派模型：继承ClassLoader，重写findClass()方法。
               2. 破坏双亲委派模型：继承ClassLoader，重写loadClass()方法。
        5. 线程上下文类加载器(Thread Context ClassLoader)：
               每个线程都有一个类加载器(jdk 1.2后引入)，称之为Thread Context ClassLoader，如果线程创建时没有设置，则默认从父线程中继承一个，如果在应用全局内都没有设置，
               则所有Thread Context ClassLoader为Application ClassLoader。可通过Thread.currentThread().setContextClassLoader(ClassLoader)来设置，通过Thread.currentThread().getContextClassLoader()来获取。
               该类加载器容许父类加载器通过子类加载器加载所需要的类库，也就是打破了双亲委派模型。
        6. 双亲委派模型：
               如果⼀个类加载器收到了加载某个类的请求，则该类加载器并不会去加载该类，⽽是把这个请求委派给⽗类加载器，每⼀个层次的类加载器都是如此，因此所有的类加载请求最终都会传送到顶端的启动类加载器。
               只有当⽗类加载器在其搜索范围内⽆法找到所需的类，并将该结果反馈给⼦类加载器，⼦类加载器会尝试去⾃⼰加载。这样的好处有：
               1. 可以避免重复加载，父类已经加载了，子类就不需要再次加载。
               2. 更加安全，很好的解决了各个类加载器的基础类的统一问题，如果不使用该种方式，那么用户可以随意定义类加载器来加载核心api，会带来相关隐患。
        7. 类加载器的特点：
               运行任何一个程序时，总是由Application Loader开始加载指定的类。一个类在收到加载类请求时，总是先交给其父类尝试加载。Bootstrap Loader是最顶级的类加载器，其父加载器为null。
        8. 类加载的三种方式：
               1. 通过命令行启动应用时由JVM初始化加载含有main()方法的主类。
               2. 通过Class.forName()方法动态加载，会默认执行初始化块（static{}），但是Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。
               3. 通过ClassLoader.loadClass()方法动态加载，不会执行初始化块。
        9. 打破双亲委派：
               因为在某些情况下⽗类加载器需要委托⼦类加载器去加载class⽂件。受到加载范围的限制，⽗类加载器⽆法加载到需要的⽂件，以Driver接⼝为例，由于Driver接⼝定义在jdk当中的，⽽其实现由各个数据库的
               服务商来提供，⽐如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接⼝的实现类，然后进⾏管理，但是DriverManager由启动类加载器加载，只
               能记载JAVA_HOME的lib下⽂件，⽽其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托⼦类来加载Driver实现，从⽽破坏了双亲委派。
               打破双亲委派的意思其实就是不委派、向下委派，例如：
               1. ⾃定义类加载器，继承ClassLoader，重写loadClass()方法。
               2. SPI：是⼀种服务发现机制。它通过在ClassPath路径下的META-INF/services⽂件夹查找⽂件，⾃动加载⽂件⾥所定义的类。这⼀机制为很多框架扩展提供了可能，⽐如在Dubbo、JDBC中都使⽤到了SPI机制。
        10. 沙箱安全：
               跟Linux的权限机制有点像，⽐如我定义了⼀个类名为String所在包为java.lang，因为这个类本来是属于jdk的，如果没有沙箱安全机制的话，这个类将会污染到我所有的String，但是由于沙箱安全机制，
               所以就委托顶层的bootstrap加载器查找这个类，如果没有的话就委托extsion，extsion没有就到appclassloader，但是由于String就是jdk的源代码，所以在bootstrap那⾥就加载到了，先找到先使⽤，
               所以就使⽤bootstrap⾥⾯的String，后⾯的⼀概不能使⽤，这就保证了不被恶意代码污染。
2.字节码文件：即.class文件，是Java编译器编译Java源文件（.java）产生的，它是一种8位字节的二进制流文件，各个数据项按顺序紧密的从前向后排列，相邻的项之间没有间隙，这样可以使得class文件非常紧凑，
            体积轻巧，可以被JVM快速的加载至内存，并且占据较少的内存空间（方便于网络的传输）。
        a. 字节码文件的结构：
               magic：魔数，class文件的标志，他是一个固定的值：0XCAFEBABE。如果开头四个字节不是0XCAFEBABE，那么就说明它不是class文件，不能被JVM识别，占4字节。
               minor version 和 major version：次版本号和主版本号，高版本的JVM能识别低版本的javac编译器编译的class文件，而低版本的JVM不能识别高版本的javac编译器编译的class文件，各占2字节。
               constant pool count：常量池数量，占2字节。
               constant pool：存放编译器⽣成的各种字⾯量(Literal)和符号引⽤(Symbolic References)，字⾯量包括：1.⽂本字符串 2.⼋种基本类型的值 3.被声明为final的常量等;符号引⽤包括：1.类和⽅法的全限定名
                              2.字段的名称和描述符 3.⽅法的名称和描述符。
               access flag：当前类的访问权限，占2字节。
               this cass：当前类的全局限定名在常量池里的索引（类名），占2字节。
               super class：当前类的父类的全局限定名在常量池里的索引（父类名），占2字节。
               interfaces count：当前类实现的接口数量，占2字节。
               interfaces[]：包含interfaces count个接口的全局限定名（实现的接口名）的索引的数组。
               fields count：类变量和实例变量的字段的数量总和（类成员的总个数），占2字节。
               fields[]：包含字段详细信息的列表（类成员详情数组）。
               methods count：该类或者接口显示定义的方法的数量，占2字节。
               method[]：包含方法信息的一个详细列表。
               attributes count：该类或者接口所定义的属性信息（attributes info）的数量，占2字节。
               attributes[]：该类或者接口所定义的属性信息，属性可以出现在class文件的很多地方，而不只是出现在attributes列表里。如果是attributes表里的属性，那么它就是对整个class文件所对应的类或者接口的描述；
                             如果出现在fields的某一项里，那么它就是对该字段额外信息的描述；如果出现在methods的某一项里，那么它就是对该方法额外信息的描述。
3.内存池与JVM内存模型：JVM内存模型其实就是JVM在启动的时候从操作系统内存中要了⼀块⼤内存，然后将这个⼤内存分成五个区域：⽅法区、堆区、虚拟机栈、本地⽅法栈、程序计数器。注意区分JVM内存模型与JMM（Java Memory Model）。
        a. 方法区：jdk1.7之前方法区的实现叫永久代，永久代和堆相互隔离，永久代的⼤⼩在启动JVM时可以设置⼀个固定值，不可变（很有可能导致永久代内存溢出），jdk1.7中存储在永久代的部分数据就已经转移到了java堆或者是
                  native堆（调用本地方法-c方法时s申请的内存空间）。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native堆；字面量(interned strings-串池)转移到了java堆；
                  类的静态变量(class statics)转移到了java堆。
                  jdk1.8取消了永久代，此时方法区的实现叫元空间，元空间本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。
                  因此默认情况下元空间的大小仅受本地内存限制。
                  方法区存放着类的版本、字段、方法、接口和常量池（存储字面量和符号引用）。
        b. 堆区：是被线程共享的一块内存区域，存放创建的实例对象以及数组，也是垃圾收集器进行垃圾收集的最重要的内存区域，JVM调优重点关注的区域，由于现代VM采用分代收集算法, 因此Java堆从GC的角度还可以
                细分为：新生代(Eden区、From Survivor区和To Survivor区)和老年代。
                异常：OutOfMemoryError
        c. 虚拟机栈：是描述java方法执行的内存模型，基于栈运⾏，每个方法在执行的同时都会创建一个栈帧（Stack Frame）。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
                   栈帧（Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、方法返回值和异常分派（Dispatch Exception）。栈帧随着方法调用而创建，
                   随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。
                   栈帧（Frame）中存储了局部变量表、操作数栈、动态链接（部分符号引用在每一次运行时期转化为直接引用的过程称为动态链接）、返回地址、附加信息等几个区域。
                   异常：StackOverflowError、OutOfMemoryError
        d. 本地⽅法栈：本地方法栈主要为Native方法服务，java通过jni调⽤C、C++动态链接库需要的栈，随着socket的发展，jni技术已经⽤得⾮常⾮常少。异常：StackOverflowError、OutOfMemoryError
        e. 程序计数器：一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，即字节码指令前⾯的index，正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是Native方法，则为空。
                     这个内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError情况的区域。
        f. 之间的关系：
              虚拟机栈与⽅法区：如何理解虚拟机栈⽅法区的引⽤-动态链接。
              虚拟机栈与堆区：如何理解虚拟机栈对堆区的引⽤-局部变量。
                  Test obj = new Test();
                  Class对象
                  instanceKlass 类的元信息
              ⽅法区与堆区：如何理解⽅法区与堆区的双向引⽤：
                  ⽅法区->堆区：引⽤类型的静态属性。
                  堆区->⽅法区：klass pointer 指向该对象的instanceKlass实例。
4.字符串常量池：jdk1.7以前位于方法区（永久代），jdk1.7及以后移到了堆区。
        a. 直接赋值字符串：String s ="11";// s指向字符串常量池中的引用
              创建该对象的时候，jvm会先去字符串常量池中通过equals(key)方法，判断是否有相同的对象，如果有，则直接返回该对象在字符串常量池中的引用。如果没有，则会在字符串常量池中创建一个新对象，再返回其引用。
              这种方式创建的字符串对象，只会在字符串常量池中。
        b. new String()：String s1 =newString("11");// s1指向内存（堆）中的对象
              创建该对象的时候，jvm会先检查字符串常量池中是否存在字符串"11"，不存在，先在字符串常量池里创建一个字符串对象，再去堆中创建一个字符串对象"11"，存在的话，就直接去堆内存中创建一个字符串对象"11"，最后将堆中的引用返回。
              这种方式会保证字符串常量池和堆中都有这个对象，没有就创建，最后返回堆内存中的对象引用。
        c. intern方法：String中的intern方法是一个native的方法，当调用intern方法时，如果字符串常量池已经包含一个等于该String对象的字符串（用equals(oject)方法确定），则返回字符串常量池中该字符串的引用。
              如果字符串常量池中不包含等于该String对象的字符串，则将该字符串放入字符串常量池中并返回其引用（jdk1.7及以后）。
              注：jdk1.7及以后调用intern方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象（jdk1.7及以前）。
5.执⾏引擎、jit(即时编译)、逃逸分析：
        a. 执⾏引擎、jit(即时编译)：
              java是半编译半解释型语⾔：1.javac编译，java运⾏ 2.运⾏期即时编译 + 解释执⾏
              jvm中两种解释器：
                  1.字节码解释器 做的事情是：java字节码->c++代码->硬编码
                  2.模板解释器 做的事情：java字节码->硬编码
                  三种运⾏模式：
                      -Xint：纯字节码解释器模式（程序简单）
                      -Xcomp：纯模板解释器模式（程序复杂）
                      -Xmixed：字节码解释器 + 模板解释器模式（默认）
              两种即时编译器：jdk1.6以前是没有混合编译的，后来根据两种编译器的使⽤场景组合起来使⽤进⼀步提升性能。
                 1.C1编译器：
                     -client模式启动，默认启动的是C1编译器。有哪些特点呢？
                     1、需要收集的数据较少，即达到触发即时编译的条件较宽松
                     2、⾃带的编译优化优化的点较少
                     3、编译时较C2，没那么耗CPU，带来的结果是编译后⽣成的代码执⾏效率较C2低
                 2.C2编译器：
                     -server模式启动。有哪些特点呢？
                     1、需要收集的数据较多
                     2、编译时很耗CPU
                     3、编译优化的点较多
                     4、编译⽣成的代码执⾏效率⾼
                 3.混合编译：
                     ⽬前都是-server模式启动，已经不是纯粹只使⽤C2。程序运⾏初期因为产⽣的数据较少，这时候执⾏C1编译，程序执⾏⼀段时间后，收集到⾜够的数据，执⾏C2编译器
              即时编译触发条件：
                 ⽬前的64bit机器上只有-server模式。⼤家现在谈执⾏引擎，说的都是-server模式启动的jvm中的执⾏引擎
                 触发即时编译的最⼩单位是代码段，最⼤单位是⽅法
                 Client 编译器模式下，N 默认的值 1500
                 Server 编译器模式下，N 默认的值则是 10000
              热点代码缓存区：
                 热点代码缓存是保存在⽅法区的，这块也是调优需要调的地⽅
                 server 编译器模式下代码缓存⼤⼩则起始于 2496KB
                 client 编译器模式下代码缓存⼤⼩起始于 160KB
                 java -XX:+PrintFlagsFinal -version | grep InitialCodeCacheSize
        b. 逃逸分析：
              在编译程序优化理论中，逃逸分析是⼀种确定指针动态范围的⽅法——分析在程序的哪些地⽅可以访问到指针。它涉及到指针分析和形状分析。java的逃逸分析只发在JIT的即时编译中，因为收集到⾜够的运⾏数据JVM可以更好的判断
              对象是否发⽣了逃逸。
              jvm判断新创建的对象是否逃逸的依据有：⼀、对象被赋值给堆中对象的字段和类的静态变量。⼆、对象被传进了不确定的代码中去运⾏。如果满⾜了以上情况的任意⼀种，那这个对象jvm就会判定为逃逸。
              对于第⼀种情况，因为对象被放进堆中，则其它线程就可以对其进⾏访问，所以对象的使⽤情况，编译器就⽆法再进⾏追踪。第⼆种情况相当于jvm在解析普通的字节码的时候，如果没有发⽣jit即时编译，
              编译器是不能事先完整知道这段代码会对对象做什么操作。保守⼀点，这个时候也只能把对象是当作是逃逸来处理.
              基于逃逸分析的优化：
                 当判断出对象不发⽣逃逸时，编译器可以使⽤逃逸分析的结果作⼀些代码优化。
                 1.将堆分配转化为栈分配。如果某个对象在⼦程序中被分配，并且指向该对象的指针永远不会逃逸，该对象就可以在分配在栈上，⽽不是在堆上。在有垃圾收集的语⾔中，这种优化可以降低垃圾收集器运⾏的频率。
                   说明：⽅法栈上的对象在⽅法执⾏完之后，栈桢弹出，对象就会⾃动回收。这样的话就不需要等内存满时再触发内存回收。这样的好处是程序内存回收效率⾼，并且GC频率也会减少，程序的性能就提⾼了。
                 2.同步消除。如果发现某个对象只能从⼀个线程可访问，那么在这个对象上的操作可以不需要同步。
                   说明：如果发现某个对象只能从⼀个线程可访问，那么在这个对象上的操作可以不需要同步。逃逸分析把锁消除了，并在性能上得到了很⼤的提升。这⾥说明⼀下java的逃逸分析是⽅法级别的，因为jit的即时编译是⽅法级别。
                 3.分离对象或标量替换。如果某个对象的访问⽅式不要求该对象是⼀个连续的内存结构，那么对象的部分（或全部）可以不存储在内存，⽽是存储在CPU寄存器中。
                   说明：这个简单来说就是把对象分解成⼀个个基本类型，并且内存分配不再是分配在堆上，⽽是分配在栈上。这样的好处有，⼀、减少内存使⽤，因为不⽤⽣成对象头。 ⼆、程序内存回收效率⾼，并且GC频率也会减少，
                        总的来说和上⾯优点⼀的效果差不多。
              虚拟机配置参数：
              -XX:+PrintGC -Xms5M -Xmn5M -XX:+DoEscapeAnalysis
                  -XX:+DoEscapeAnalysis表示开启逃逸分析，jdk1.8是默认开启的，-DoEscapeAnalysis表示关闭逃逸分析
                  -XX:+PrintGC 表示打印GC信息 -PrintGC 表示不打印GC信息
                  -Xms5M -Xmn5M 设置jvm内存⼤⼩是5M
6.垃圾回收算法：

7.强软弱虚引⽤与垃圾收集器：

8.jvm调优及实战：详见pdf文件






