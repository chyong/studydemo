1.类加载：
  a. klass模型:
     Java的每个类，在JVM中，都有⼀个对应的Klass类实例与之对应，存储类的元信息如：常量池、属性信息、⽅法信息等，类的元信息是存储在原空间的，普通的Java类在JVM中对应的是instanceKlass类的实例，它的三个⼦类
        1. InstanceMirrorKlass：⽤于表示java.lang.Class，Java代码中获取到的Class对象，实际上就是这个C++类的实例，存储在堆区，学名镜像类。
        2. InstanceRefKlass：⽤于表示java/lang/ref/Reference类的⼦类。
        3. InstanceClassLoaderKlass：⽤于遍历某个加载器加载的类。
     Java中的数组不是静态数据类型，是动态数据类型，即是运⾏期⽣成的，Java数组的元信息⽤ArrayKlass的⼦类来表示：
        1. TypeArrayKlass：⽤于表示基本类型的数组。
        2. ObjArrayKlass：⽤于表示引⽤类型的数组。
  b. 类加载的过程:
     类加载机制分为五个部分：加载，验证，准备，解析，初始化
        1. 加载：加载是类加载过程的第一个阶段，这个阶段主要完成以下三件事：
                1. 通过一个类的全限定名来获取其定义的二进制字节流。
                2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，即instanceKlass实例。
                3. 在Java堆中生成一个代表这个类的java.lang.Class对象，即instanceMirrorKlass实例，作为对方法区中这些数据的访问入口。
                注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。
        2. 验证：这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，主要分为四步：⽂件格式验证、元数据验证、字节码验证、符号引⽤验证。
        3. 准备：给类变量（static静态变量）分配内存、赋初值（这里的初值指的是数据类型默认的零值，真正的赋值过程发生在类构造器的<clinit>()方法中），注意这里不是给实例变量赋值，实例变量是在创建实例时进行赋值的，如果
                该变量被final修饰，在编译的时候会给属性添加ConstantValue属性，准备阶段直接完成赋值。
        4. 解析：将常量池中的符号引⽤转为直接引⽤，符号引用是用一组符号来描述目标，可以是任何字面量，而直接引用则是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。举个例子来说明，
                在com.sbbic.Person类中引用了com.sbbic.Animal类，在编译阶段，Person类并不知道Animal的实际内存地址，因此只能用com.sbbic.Animal来代表Animal真实的内存地址。在解析阶段，JVM可以通过解析该符号引用，
                来确定com.sbbic.Animal类的真实内存地址（如果该类未被加载过，则先加载），主要有以下四种：类或接口的解析、字段解析、类方法解析、接口方法解析，何时解析：加载阶段解析常量池时、用的时候。
        5. 初始化：类加载过程的最后一步，到该阶段才真正开始执行类中定义的java代码，同样该阶段也是初始化类变量（完成静态变量的赋值）和其他资源（执行静态字段和静态代码块），换句话说该阶段是执行类构造器<clinit>()方法的过程。
                 <clinit>()方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕（父类的静态语句块和静态变量优先于子类中变量赋值操作），
                 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<clinit>()方法。
  c. 类加载器：把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作交给虚拟机之外的类加载器来完成。这样的好处在于，我们可以自行实现类加载器来加载其他格式的类，只要是二进制字节流就行，这就大大增强了加载器灵活性。
        1. 启动类加载器(Bootstrap ClassLoader)：
               由C/C++实现，负责加载<JAVA_HOME>\jre\lib目录下或者是-Xbootclasspath所指定路径下目录以及系统属性sun.boot.class.path制定的目录中特定名称的jar包到虚拟机内存中。
               在JVM启动时，通过Bootstrap ClassLoader加载rt.jar，并初始化sun.misc.Launcher从而创建Extension ClassLoader和Application ClassLoader的实例。需要注意的是，Bootstrap ClassLoader只会加载特定名称的类库，
               比如rt.jar，这意味我们自定义的jar扔到<JAVA_HOME>\jre\lib也不会被加载。
        2. 扩展类加载器（Extension Classloader）：
               只有一个实例，由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>\lib\ext目录下或是被系统属性java.ext.dirs所指定路径目录下的所有类库。
        3. 应用程序类加载器(Application ClassLoader)：
               只有一个实例，由sun.misc.Launcher$AppClassLoader实现，负责加载系统环境变量ClassPath或者系统属性java.class.path指定目录下的所有类库，
               如果应用程序中没有定义自己的加载器，则该加载器也就是默认的类加载器。该加载器可以通过java.lang.ClassLoader.getSystemClassLoader获取。
        4. 自定义类加载器：
               1. 遵守双亲委派模型：继承ClassLoader，重写findClass()方法。
               2. 破坏双亲委派模型：继承ClassLoader，重写loadClass()方法。
        5. 线程上下文类加载器(Thread Context ClassLoader)：
               每个线程都有一个类加载器(jdk 1.2后引入)，称之为Thread Context ClassLoader，如果线程创建时没有设置，则默认从父线程中继承一个，如果在应用全局内都没有设置，
               则所有Thread Context ClassLoader为Application ClassLoader。可通过Thread.currentThread().setContextClassLoader(ClassLoader)来设置，通过Thread.currentThread().getContextClassLoader()来获取。
               该类加载器容许父类加载器通过子类加载器加载所需要的类库，也就是打破了双亲委派模型。
        6. 双亲委派模型：
               如果⼀个类加载器收到了加载某个类的请求，则该类加载器并不会去加载该类，⽽是把这个请求委派给⽗类加载器，每⼀个层次的类加载器都是如此，因此所有的类加载请求最终都会传送到顶端的启动类加载器。
               只有当⽗类加载器在其搜索范围内⽆法找到所需的类，并将该结果反馈给⼦类加载器，⼦类加载器会尝试去⾃⼰加载。这样的好处有：
               1. 可以避免重复加载，父类已经加载了，子类就不需要再次加载。
               2. 更加安全，很好的解决了各个类加载器的基础类的统一问题，如果不使用该种方式，那么用户可以随意定义类加载器来加载核心api，会带来相关隐患。
        7. 类加载器的特点：
               运行任何一个程序时，总是由Application Loader开始加载指定的类。一个类在收到加载类请求时，总是先交给其父类尝试加载。Bootstrap Loader是最顶级的类加载器，其父加载器为null。
        8. 类加载的三种方式：
                1. 通过命令行启动应用时由JVM初始化加载含有main()方法的主类。
                2. 通过Class.forName()方法动态加载，会默认执行初始化块（static{}），但是Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。
                3. 通过ClassLoader.loadClass()方法动态加载，不会执行初始化块。
        9. 打破双亲委派：
                因为在某些情况下⽗类加载器需要委托⼦类加载器去加载class⽂件。受到加载范围的限制，⽗类加载器⽆法加载到需要的⽂件，以Driver接⼝为例，由于Driver接⼝定义在jdk当中的，⽽其实现由各个数据库的
                服务商来提供，⽐如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接⼝的实现类，然后进⾏管理，但是DriverManager由启动类加载器加载，只
                能记载JAVA_HOME的lib下⽂件，⽽其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托⼦类来加载Driver实现，从⽽破坏了双亲委派。
                打破双亲委派的意思其实就是不委派、向下委派，例如：
                1. ⾃定义类加载器，继承ClassLoader，重写loadClass()方法。
                2. SPI：是⼀种服务发现机制。它通过在ClassPath路径下的META-INF/services⽂件夹查找⽂件，⾃动加载⽂件⾥所定义的类。这⼀机制为很多框架扩展提供了可能，⽐如在Dubbo、JDBC中都使⽤到了SPI机制。
        10. 沙箱安全：
                跟Linux的权限机制有点像，⽐如我定义了⼀个类名为String所在包为java.lang，因为这个类本来是属于jdk的，如果没有沙箱安全机制的话，这个类将会污染到我所有的String，但是由于沙箱安全机制，
                所以就委托顶层的bootstrap加载器查找这个类，如果没有的话就委托extsion，extsion没有就到appclassloader，但是由于String就是jdk的源代码，所以在bootstrap那⾥就加载到了，先找到先使⽤，
                所以就使⽤bootstrap⾥⾯的String，后⾯的⼀概不能使⽤，这就保证了不被恶意代码污染。
  d. 字节码文件：