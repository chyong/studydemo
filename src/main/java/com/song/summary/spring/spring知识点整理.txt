Spring常见面试题：https://www.yuque.com/books/share/9f4576fb-9aa9-4965-abf3-b3a36433faa6/vg6lw0#bRUgi
1.spring Bean生命周期：
    Bean生命周期指的是spring中一个Bean从创建到销毁的过程。简单描述：
        1.解析类得到BeanDefinition。
        2.如果有多个构造方法，则要推断构造方法。
        3.确定好构造方法后，进行实例化得到一个对象。
        4.对对象中的加了@Autowired注解的属性进行属性填充。
        5.回调Aware方法，比如BeanNameAware，BeanFactoryAware。
        6.调用BeanPostProcessor的初始化前的方法。
        7.调用初始化方法。
        8.调用BeanPostProcessor的初始化后的方法，在这里会进行AOP。
        9.如果当前创建的bean是单例的则会把bean放入单例池。
        10.使用bean。
        11.Spring容器关闭时调用DisposableBean中destory()方法。
    详解：
        a.Bean生成的过程：
            1.生成BeanDefinition：
                Spring启动的时候会进行扫描，会先调用 Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); 拿到所指定的包路径下的所有文件资源（******.class文件）
                然后会遍历每个Resource，为每个Resource生成一个MetadataReader对象，在生成MetadataReader对象时，会利用ASM技术解析class文件，得到类的元数据集信息和注解信息，
                在这个过程中也会利用ClassLoader去加载注解类（ClassUtils.getDefaultClassLoader()所获得的类加载器），但是不会加载本类。有了MetadataReader对象，就相当于有了当前类的所有信息，但是当前类并没有加载，
                真正在用到这个类的时候才加载。然后利用MetadataReader对象生成一个ScannedGenericBeanDefinition对象，注意此时的BeanDefinition对象中的beanClass属性存储的是当前类的名字，而不是class对象
                （beanClass属性的类型是Object，它即可以存储类的名字，也可以存储class对象）。
            2.合并BeanDefinition：
                如果某个BeanDefinition存在父BeanDefinition，那么则要进行合并。
            3.加载类：
                有了BeanDefinition之后，后续就会基于BeanDefinition去创建Bean，而创建Bean就必须实例化对象，而实例化就必须先加载当前BeanDefinition所对应的class，
                在AbstractAutowireCapableBeanFactory类的createBean()方法中，一开始就会调用 Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
                去加载类，其中doResolveBeanClass方法会判断beanClass属性的类型是不是Class对象，如果是，那么就直接返回，如果不是，则会根据类名进行加载。
                会利用BeanFactory所设置的类加载器来加载类，如果没有设置，则默认使用ClassUtils.getDefaultClassLoader()所返回的类加载器来加载。
                ClassUtils.getDefaultClassLoader()：
                    a.优先获取当前线程中的ClassLoader。
                    b.如果为空，则获取加载ClassUtils类的类加载器（正常情况下，就是AppClassLoader，但是如果是在Tomcat中运行，那么则会是Tomcat中为每个应用所创建的WebappClassLoader）。
                    c.如果还是为空，那么则是bootstrap类加载器加载的ClassUtils类，那则获取系统类加载器进行加载。
            4.实例化前：
                允许第三方可以不按照Spring的正常流程来创建一个Bean，可以利用InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation方法来提前返回一个Bean对象，直接结束Bean的生命周期。
            5.推断构造方法：
                https://www.yuque.com/books/share/9f4576fb-9aa9-4965-abf3-b3a36433faa6/ng6l6p
            6.实例化：
                通过构造方法反射得到一个实例。
            7.BeanDefinition的后置处理：
                这里可以处理BeanDefinition，但是此时实例对象已经生成好了，所以修改beanClass已经没用了，但是可以修改PropertyValues。
            8.填充属性：依赖注入
            9.执行Aware：
                比如BeanNameAware，BeanFactoryAware等等，Aware表示回调，Spring会回调Aware接口中的方法，而程序员就可以在Aware接口的方法中去进行干涉。
            10.初始化前
            11.初始化
            12.初始化后
        b.Bean使用
        c.Bean销毁的过程：
            1.容器关闭。
            2.发布ContextClosedEvent事件。
            3.调用LifecycleProcessor的onClose方法。
            4.销毁单例Bean。
                a.找出所有DisposableBean(实现了DisposableBean接口的Bean)。
                b.遍历每个DisposableBean。
                c.找出依赖了当前DisposableBean的其他Bean，将这些Bean从单例池中移除掉。
                d.调用DisposableBean的destroy()方法。
                e.找到当前DisposableBean所包含的inner beans，将这些Bean从单例池中移除掉。
                这里涉及到一个设计模式：适配器模式，在销毁时，Spring会找出实现了DisposableBean接口的Bean。但是我们在定义一个Bean时，如果这个Bean实现了DisposableBean接口，或者实现了AutoCloseable接口，
                或者在BeanDefinition中指定了destroyMethodName，那么这个Bean都属于“DisposableBean”，这些Bean在容器关闭时都要调用相应的销毁方法。所以这里就需要进行适配，将实现了DisposableBean接口
                或者AutoCloseable接口等适配成实现了DisposableBean接口，所以就用到了DisposableBeanAdapter。会把实现了AutoCloseable接口的类封装成DisposableBeanAdapter，
                而DisposableBeanAdapter实现了DisposableBean接口。
        Spring中的“父子”：
            1.父子类：
                父子类是Java中的概念，在Spring中，当给某个类创建Bean的过程中，Spring不仅仅会对本类中的属性进行自动注入，同时也会对父类的属性进行自动注入。
            2.父子BeanDefinition：
                父子BeanDefinition是Spring中的概念，Spring在根据BeanDefinition创建Bean的过程中，会先看当前BeanDefinition是否存在父BeanDefinition，如果存在则需要进行合并，
                合并就是把子BeanDefinition和父BeanDefinition中所定义的属性整合起来（如果存在某个属性在父子BeanDefinition中都存在，那么取子BeanDefinition中的属性）。
            3.父子BeanFactory：
                BeanFactory是一个Bean的容器，在Spring中，当我们在使用某个BeanFactory去获取Bean时，如果本BeanFactory中不存在该Bean，同时又有父BeanFactory，
                那么则会检查父BeanFactory是否存在该Bean，如果也不存在，那么则会创建Bean。
            4.父子ApplicationContext：
                父子ApplicationContext和父子BeanFactory类似，子ApplicationContext除了可以使用父ApplicationContext来获取Bean之外，还可以使用父ApplicationContext中其他的东西，比如ApplicationListener。
        BeanPostProcessor(Bean的后置处理器，注意与BeanFactory的后置处理器区分)：
            Bean的后置处理器是指Spring在创建一个Bean的过程中，可以通过后置处理器来干涉Bean的创建过程。
            一个简单的Bean的生命周期：
                1.推断构造方法(确定使用哪个构造方法来实例化对象)
                2.实例化
                3.填充属性
                4.初始化
            Spring在这个基础上，在这4步中的某些"间隙"中增加了扩展点，比如：
                1.BeanPostProcessor：提供了初始化前、初始化后。
                2.InstantiationAwareBeanPostProcessor：在BeanPostProcessor的基础上增加了实例化前、实例化后、填充属性后。
                3.MergedBeanDefinitionPostProcessor：在BeanPostProcessor的基础上增加了在实例化和实例化后之间的扩展点。
        BeanFactory的后置处理器：
            Spring中的BeanFactory的后置处理器是Spring中提供的一个扩展点，允许程序员自己去定义一个BeanFactory的后置处理器，因为Spring中设计了这个机制，在Spring源码的内部也利用了BeanFactory的后置处理器，
            比如ConfigurationClassPostProcessor，它就是一个BeanFactory的后置处理器，它负责解析配置类，完成扫描，把扫描得到的BeanDefinition注册到BeanFactory中。BeanFactory的后置处理器中可以拿到BeanFactory，
            而拿到BeanFactory之后就可以使用BeanFactory中存储的东西了，比如BeanDefinition，比如可以创建Bean。如果定义了多个BeanFactory的后置处理器，可以通过实现Ordered接口来控制BeanFactory的后置处理器的执行顺序。
2.spring IOC：
    IOC是Spring Framework中众多特性中的一个特性，表示控制反转，Spring相当于项目里的管家，管理项目中的对象，控制反转，表示对象的控制权本来是在程序员手中的，现在交给了Spring，所以Spring获得了对象的控制权，
    比如，Spring负责去进行实例化得到对象，Spring负责通过反射去给对象中的属性进行赋值，这些动作都不需要程序员去做，Spring自动帮程序员做了。
    a.Spring中到底有几种依赖注入的方式？
        首先分两种：
        1.手动注入：
            在XML中定义Bean时，就是手动注入，因为是程序员手动给某个属性指定了值。手动注入的底层也就是分为两种：set方法与构造方法。
        2.自动注入
            a.XML的autowire自动注入：
                在XML中，我们可以在定义一个Bean时去指定这个Bean的自动注入模式：
                    1.byType
                    2.byName
                    3.constructor
                    4.default
                    5.no
                比如：<bean id="userService" class="com.luban.service.UserService" autowire="byType"/>
                这么写，表示Spring会自动的给userService中所有的属性自动赋值（不需要这个属性上有@Autowired注解，但需要这个属性有对应的set方法）。
                在创建Bean的过程中，在填充属性时，Spring会去解析当前类，把当前类的所有方法都解析出来，Spring会去解析每个方法得到对应的PropertyDescriptor对象，注意PropertyDescriptor并不是Spring中的类，
                而是java.beans包下类，也就是jdk自带的类，PropertyDescriptor中有几个属性：
                    1.name：这个name并不是方法的名字，而是拿方法名字进过处理后的名字
                        a.如果方法名字以“get”开头，比如“getXXX”,那么name=XXX
                        b.如果方法名字以“is”开头，比如“isXXX”,那么name=XXX
                        c.如果方法名字以“set”开头，比如“setXXX”,那么name=XXX
                    2.readMethodRef：表示get方法的Method对象的引用
                    3.readMethodName：表示get方法的名字
                    4.writeMethodRef：表示set方法的Method对象的引用
                    5.writeMethodName：表示set方法的名字
                    6.propertyTypeRef：如果有get方法那么对应的就是返回值的类型，如果是set方法那么对应的就是set方法中唯一参数的类型
                get方法的定义是： 方法参数个数为0个，并且 （方法名字以"get"开头 或者 方法名字以"is"开头并且方法的返回类型为boolean）
                set方法的定义是：方法参数个数为1个，并且 （方法名字以"set"开头并且方法返回类型为void）
                所以，Spring在通过byName的自动填充属性时流程是：
                    1.找到所有set方法所对应的XXX部分的名字
                    2.根据XXX部分的名字去获取bean
                Spring在通过byType的自动填充属性时流程是：
                    1.找到所有set方法所对应的XXX部分的名字
                    2.根据XXX部分的名字重新再获取得到PropertyDescriptor
                    3.获取到set方法中的唯一参数的类型，并且根据该类型去容器中获取bean
                    4.如果找到多个，会报错。
                以上，分析了autowire的byType和byName情况，那么接下来分析constructor，constructor表示通过构造方法注入，其实这种情况就比较简单了，没有byType和byName那么复杂。
                首先，如果是byType或byName，那么该bean一定要有一个无参的构造方法，因为如果只有有参构造方法，那么Spring将无法进行实例化，因为Spring如果要实例化肯定需要利用构造方法，而Spring没法给构造方法传值。
                然后，如果是constructor，那么就可以不写set方法了，当某个bean是通过构造方法来注入时，表示Spring在利用构造方法实例化一个对象时，可以利用构造方法的参数信息从Spring容器中去找bean，
                找到bean之后作为参数传给构造方法，从而实例化得到一个bean对象。
                我们这里先不考虑一个类有多个构造方法的情况，后面单独讲推断构造方法。我们这里只考虑只有一个有参构造方法。
                其实构造方法注入相当于byType+byName，普通的byType是根据set方法中的参数类型去找bean，找到多个会报错，而constructor就是通过构造方法中的参数类型去找bean，如果找到多个会根据参数名确定。
                另外两个：
                    1.no，表示关闭autowire
                    2.default，表示默认值，我们一直演示的某个bean的autowire，而也可以直接在<beans>标签中设置autowire，如果设置了，那么<bean>标签中设置的autowire如果为default，
                      那么则会用<beans>标签中设置的autowire。
                可以发现XML中的自动注入是挺强大的，那么问题来了，为什么我们平时都是用的@Autowired注解呢？而没有用上文说的这种自动注入方式呢？
                @Autowired注解相当于XML中的autowire属性的注解方式的替代。从本质上讲，@Autowired注解提供了与autowire相同的功能，但是拥有更细粒度的控制和更广泛的适用性。
                注意：更细粒度的控制。
                XML中的autowire控制的是整个bean的所有属性，而@Autowired注解是直接写在某个属性、set方法、构造方法上的。
                再举个例子，如果一个类有多个构造方法，那么如果用XML的autowire=constructor，你无法控制到底用哪个构造方法，而你可以用@Autowired注解来直接指定你想用哪个构造方法。
                同时，用@Autowired注解，还可以控制，哪些属性想被自动注入，哪些属性不想，这也是细粒度的控制。
                但是@Autowired无法区分byType和byName，@Autowired是先byType，如果找到多个则byName。
                那么XML的自动注入底层其实也就是:
                    1.set方法
                    2.构造方法
            b.@Autowired注解的自动注入：

                @Autowired注解表示自动注入，是Spring体系中Java Config取代xml中的一种，因为在使用xml时也可以设置是否需要自动注入，只不过Spring默认是关闭的，所以不为人所知。
                而@Autowired注解则取代了xml中的自动注入功能，并进行了优化，使得Spring中的自动注入功能更加方便使用。
                @Autowired注解可以写在属性上，构造方法上，普通方法上，表示Spring在进行生命周期的过程中可以通过这些属性和方法进行属性的自动填充，比如写在属性上，
                那么Spring就会先根据属性的类型（byType）去Spring容器找对应类型的bean，如果找到一个则通过反射赋值给该属性，如果找到多个则再根据属性的名字确定其中一个bean，如果根据名字没有找到则报错，
                如果找到了，则把这个bean也是通过反射的方式赋值给这个属性。如果@Autowired注解是普通方法上，也就是我们平时说的setter方法上，那么Spring会根据setter方法的参数类型去找bean，
                找到多个再根据根据属性的名字去进行筛选，找到了bean之后再调用set方法进行赋值。

                上文说了@Autowired注解，是byType和byName的结合。
                @Autowired注解可以写在：
                    1.属性上：先根据属性类型去找Bean，如果找到多个再根据属性名确定一个
                    2.构造方法上：先根据方法参数类型去找Bean，如果找到多个再根据参数名确定一个
                    3.set方法上：先根据方法参数类型去找Bean，如果找到多个再根据参数名确定一个
                而这种底层到了：
                    1.属性
                    2.set方法
                    3.构造方法
                @Autowired底层实现原理：
                    找出注入点
                    在创建一个Bean的过程中，Spring会利用AutowiredAnnotationBeanPostProcessor的postProcessMergedBeanDefinition()找出注入点，加了@Autowired注解的就是注入点，比如：
                        1.某个属性
                        2.某个方法（先不管构造方法）
                    把这些注入点信息找出来之后会进行缓存中（Set<InjectedElement>），InjectedElement就表示注入点
                    进行注入
                    Spring会利用AutowiredAnnotationBeanPostProcessor的postProcessProperties()方法中，会遍历Set<InjectedElement>中的注入点开始进行注入。
    b.DefaultListableBeanFactory中resolveDependency()方法具体实现见图片，该方法表示，传入一个依赖描述（DependencyDescriptor），该方法会根据该依赖描述从BeanFactory中找出对应的唯一的一个Bean对象。
    c.@Resource注解底层原理：
        具体实现流程见图片
        总结，对于@Resource：
            1.如果@Resource注解中指定了name属性，那么则只会根据name属性的值去找bean，如果找不到则报错
            2.如果@Resource注解没有指定name属性，那么会先判断当前注入点名字（属性名字或方法参数名字）是不是存在Bean，如果存在，则直接根据注入点名字取获取bean，如果不存在，则会走@Autowired注解的逻辑，
              会根据注入点类型去找Bean
3.spring AOP：
    AOP表示面向切面编程，是Spring Framework中众多特性中的一个特性，AOP可以对某个对象或某些对象的功能进行增加，比如对象中的方法进行增加，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情，
    通常，我们会利用AOP机制来实现权限控制，日志记录，缓存，包括Spring中的事务也是通过AOP来实现的。在Spring中，AOP是通过动态代理来实现的。
    https://www.yuque.com/books/share/9f4576fb-9aa9-4965-abf3-b3a36433faa6/fwhx5s
4.spring循环依赖：
    Spring中之所以会出现循环依赖跟Bean的生命周期有关系，在创建一个Bean的过程中如果依赖的另外一个Bean还没有创建，就会需要去创建依赖的那个Bean，而如果两个Bean相互依赖的话，就会出现循环依赖的问题。
    Spring使用三级缓存解决了循环依赖的问题：
        1.第一级缓存是单例池singletonObjects：它是用来保存经过了完整生命周期之后的bean。
        2.第二级缓存是earlySingletonObjects：它是用来保存暂时还没有经过完整生命周期的bean。
        3.第三级缓存是singletonFactories：它是用来保存提前进行AOP的工厂，它的作用是预先准备一个工厂，这个工厂是在需要时才执行
    https://www.yuque.com/books/share/9f4576fb-9aa9-4965-abf3-b3a36433faa6/ghhnkw
5.spring事务：
    在使用Spring框架时，可以有两种使用事务的方式，一种是编程式的，一种是申明式的，@Transactional注解就是申明式的。首先，事务这个概念是数据库层面的，Spring只是基于数据库中的事务进行了扩展，
    以及提供了一些能让程序员更加方便操作事务的方式。比如我们可以通过在某个方法上增加@Transactional注解，就可以开启事务，这个方法中所有的sql都会在一个事务中执行，统一成功或失败。
    在一个方法上加了@Transactional注解后，Spring会基于这个类生成一个代理对象，会将这个代理对象作为bean，当在使用这个代理对象的方法时，如果这个方法上存在@Transactional注解，
    那么代理逻辑会先把事务的自动提交设置为false，然后再去执行原本的业务逻辑方法，如果执行业务逻辑方法没有出现异常，那么代理逻辑中就会将事务进行提交，如果执行业务逻辑方法出现了异常，那么则会将事务进行回滚。
    当然，针对哪些异常回滚事务是可以配置的，可以利用@Transactional注解中的rollbackFor属性进行配置，默认情况下会对RuntimeException和Error进行回滚。
    https://www.yuque.com/books/share/9f4576fb-9aa9-4965-abf3-b3a36433faa6/ifr9g6
6.ApplicationContext启动过程：
    简单步骤：
        1.初始化一个Reader和Scanner，Reader可以用来注册单个BeanDefinition，Scanner用来扫描得到BeanDefinition。
        2.通过Reader把配置类注册为一个BeanDefinition。
        3.调用refresh方法，开始启动Spring容器。
        4.先获取一个Bean工厂。
        5.预先往Bean工厂中添加一些Bean后置处理器，和一些单例bean，和一些其他的配置。
        6.执行Bean工厂的后置处理器，这里会进行扫描，扫描bean和bean的后置处理器。
        7.实例化bean的后置处理器并且排序，然后添加到Bean工厂中去。
        8.初始化用来进行国际化的MessageSource。
        9.初始化事件广播器。
        10.注册事件监听器。
        11.开始实例化非懒加载的单例bean。
        12.发布ContextRefreshedEvent事件。
    详解：https://www.yuque.com/books/share/9f4576fb-9aa9-4965-abf3-b3a36433faa6/bcoppm
