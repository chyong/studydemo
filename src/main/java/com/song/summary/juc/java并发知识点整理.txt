1.进程与线程：
    进程：进程是程序的一次执行，是系统进行资源分配和调度的独立单位。
    线程：线程是比进程更小的能独立运行的基本单位（基本的cpu执行单元），是轻量级的进程，也是进程的一个实体。一个进程可以包含多个线程，线程基本不拥有系统资源，只拥有一些运行时必不可少的资源，
         比如程序计数器、寄存器和栈等。线程与同属一个进程的其他线程共享进程的全部资源，线程的上下文切换可以减少程序并发执行时的时间和空间开销，使得操作系统具有更好的并发性。
2.JMM内存模型（java内存模型）：
    a.什么是JMM内存模型？：JMM内存模型描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性、有序性、可见性展开的。模型中主要为线程、工作内存、主内存之间的交互。
        JMM内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间中，
        然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，
        线程间的通信(传值)必须通过主内存来完成。
    b.JMM与硬件内存架构的关系：JMM模型跟CPU缓存模型结构类似，是基于CPU缓存模型建立起来的，JMM模型是标准化的，屏蔽掉了底层不同计算机的区别。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，
        并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，因为JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，
        当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。
    c.Java内存模型内存交互操作：关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成。
        1.数据同步八大原子操作：
            lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态。
            unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
            read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。
            load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
            use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎。
            assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量。
            store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
            write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中。
        把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。
        但Java内存模型只要求上述8大操作(原子操作)必须按顺序执行，而没有保证必须是连续执行。
        2.同步规则：
            1.不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中
            2.一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。
            3.一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。
            4.如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。
            5.如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
            6.对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。
        3.交互举例：图片及代码见附件
            详解：对于ThreadA，会经过read、load操作将flag读入工作内存（本地内存），然后use操作写入cpu core1（寄存器保存）对于ThreadB，也会有上面的步骤。但最后是写入cpu core2（因为cpu core1一直在被占用），
                 然后给flag赋值为false，再经过assign操作写回工作内存，注意，此时不会立马执行store、write操作，写回主内存，而是在某一时刻进行，此时，ThreadA继续读取flag，是从工作内存中加载的，
                 不是从主内存中加载的。
                 load函数中doSomething(0);传入的值，从0到4：
                     0，什么也不做，while(flag)一直在进行，threadA的工作内存缓存一直有效，因此一直未从主内存中读取，一直是true。
                     1，sleep，会让出CPU时间片，线程上下文切换（保存现场、恢复现场），因此会从主内存中重新读取flag，读到了false则跳出循环。
                        注意：与sleep的时间没有关系，即使sleep 0ms，也会让出CPU时间片。
                     2，使用System.out.println输出，println方法实现内部有synchronized(this)操作，synchronized会保证可见性，因此会从主内存中读取flag。读到了false则跳出循环。
                     3，等待10微秒，太短了，缓存未失效，因此一直未从主内存中读取，一直是true。
                     4，等到20微秒，缓存失效了，因此会从主内存中读取，读到了false则跳出循环。
                 给flag变量加上volatile关键词后 private volatile boolean flag = true; 上述0-4，执行都会跳出循环。
            上面例子表示了volatile关键字的含义之一：保证变量对所有线程的可见性。
3.volatile底层实现原理：
    a.
