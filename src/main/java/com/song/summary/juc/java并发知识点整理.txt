1.进程与线程：
    进程：进程是程序的一次执行，是系统进行资源分配和调度的独立单位。
    线程：线程是比进程更小的能独立运行的基本单位（基本的cpu执行单元），是轻量级的进程，也是进程的一个实体。一个进程可以包含多个线程，线程基本不拥有系统资源，只拥有一些运行时必不可少的资源，
         比如程序计数器、寄存器和栈等。线程与同属一个进程的其他线程共享进程的全部资源，线程的上下文切换可以减少程序并发执行时的时间和空间开销，使得操作系统具有更好的并发性。
2.JMM内存模型（java内存模型）：
    回答JMM模型，要把握两个点：
        1.私有数据区域与共享数据区域的交互，或者线程与线程之间的交互。
        2.是一个抽象的模型，屏蔽掉了不同操作系统处理之间的差异。
    a.什么是JMM内存模型？：JMM内存模型描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性、有序性、可见性展开的。模型中主要为线程、工作内存、主内存之间的交互。
        JMM内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间中，
        然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，
        线程间的通信(传值)必须通过主内存来完成。
    b.JMM与硬件内存架构的关系：JMM模型跟CPU缓存模型结构类似，是基于CPU缓存模型建立起来的，JMM模型是标准化的，屏蔽掉了底层不同计算机的区别。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，
        并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，因为JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，
        当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。
    c.Java内存模型内存交互操作：关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成。
        1.数据同步八大原子操作：
            lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态。
            unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
            read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。
            load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
            use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎。
            assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量。
            store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
            write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中。
        把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。
        但Java内存模型只要求上述8大操作(原子操作)必须按顺序执行，而没有保证必须是连续执行。
        补充：
            Java线程内存模型（JMM）是建立在先行发生（happens-before）的内存模型之上的，并进行了增强。
            happens-before内存模型：先行发生模型。如果有两个操作A和B存在A Happens-Before B，那么操作A对变量的修改对操作B来说是可见的。这个先行并不是代码执行时间上的先后关系，而是保证执行结果是顺序的。
                                  即在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。
            happens-before定义：1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
                               2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，
                                  那么这种重排序并不非法。
            happens-before原则：
                1.程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
                2.锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；
                3.volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
                4.传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
                5.线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
                6.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
                7.线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
                8.对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。
        2.同步规则：
            1.不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中
            2.一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。
            3.一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。
            4.如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。
            5.如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
            6.对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。
        3.交互举例：图片及代码见附件
            详解：对于ThreadA，会经过read、load操作将flag读入工作内存（本地内存），然后use操作写入cpu core1（寄存器保存）对于ThreadB，也会有上面的步骤。但最后是写入cpu core2（因为cpu core1一直在被占用），
                 然后给flag赋值为false，再经过assign操作写回工作内存，注意，此时不会立马执行store、write操作，写回主内存，而是在某一时刻进行，此时，ThreadA继续读取flag，是从工作内存中加载的，
                 不是从主内存中加载的。
                 load函数中doSomething(0);传入的值，从0到4：
                     0，什么也不做，while(flag)一直在进行，threadA的工作内存缓存一直有效，因此一直未从主内存中读取，一直是true。
                     1，sleep，会让出CPU时间片，线程上下文切换（保存现场、恢复现场），因此会从主内存中重新读取flag，读到了false则跳出循环。
                        注意：与sleep的时间没有关系，即使sleep 0ms，也会让出CPU时间片。
                     2，使用System.out.println输出，println方法实现内部有synchronized(this)操作，synchronized会保证可见性，因此会从主内存中读取flag。读到了false则跳出循环。
                     3，等待10微秒，太短了，缓存未失效，因此一直未从主内存中读取，一直是true。
                     4，等到20微秒，缓存失效了，因此会从主内存中读取，读到了false则跳出循环。
                 给flag变量加上volatile关键词后 private volatile boolean flag = true; 上述0-4，执行都会跳出循环。
            上面例子表示了volatile关键字的含义之一：保证变量对所有线程的可见性。
3.并发的三大特性：
    a.原子性（Atomicity）：即一个操作或者多个操作，要么全部执行并且不被打断，要么就都不执行。
    b.可见性（Visibility）：当一个线程修改了共享变量的值，其他线程会马上知道这个修改。当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从缓存中读取。
    c.有序性（Ordering）：虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按照我们写的代码的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，
                        虽然对变量的值没有造成影响，但有可能会出现线程安全问题。
4.volatile底层实现原理：
    a.volatile内存语义：
        volatile是Java虚拟机提供的轻量级的同步机制。
        volatile语义有如下两个作用：
        1.可见性：保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。
        2.有序性：禁止指令重排序优化。
    b.volatile缓存可见性实现原理：
        1.JMM内存交互层面：volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步回主内存，使用时必须从主内存刷新，由此保证volatile变量的可见性。
        2.底层实现：通过汇编lock前缀指令，它会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。
                  一个处理器的缓存回写到内存会导致其他处理器的缓存无效。
        汇编代码查看：-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp
        补充：
            1.Lock作用：
                a. 确保后续指令执行的原子性。在Pentium及之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其它处理器暂时无法通过总线访问内存，很显然，这个开销很大。在新的处理器中，
                   Intel使用缓存锁定来保证指令执行的原子性，缓存锁定将大大降低lock前缀指令的执行开销。
                b. 禁止该指令与前面和后面的读写指令重排序。
                c. 把写缓冲区的所有数据刷新到主内存中。
            2.缓存一致性协议（MESI）：
                MESI协议是当前最主流的缓存一致性协议，在MESI协议中，每个缓存行有4个状态，可用2个bit表示，它们分别是：Modified（修改）、Exclusive（独占，互斥）、Share（共享）、Invalid（无效）。详见图片
                这里的I、S和M状态已经有了对应的概念：失效/未载入、干净以及脏的缓存段。所以这里新的知识点只有E状态，代表独占式访问，这个状态解决了"在我们开始修改某块内存之前，我们需要告诉其它处理器"这一问题：
                只有当缓存行处于E或者M状态时，处理器才能去写它，也就是说只有在这两种状态下，处理器是独占这个缓存行的。当处理器想写某个缓存行时，如果它没有独占权，它必须先发送一条"我要独占权"的请求给总线，
                这会通知其它处理器把它们拥有的同一缓存段的拷贝失效（如果有）。只有在获得独占权后，处理器才能开始修改数据----并且此时这个处理器知道，这个缓存行只有一份拷贝，在我自己的缓存里，所以不会有任何冲突。
                反之，如果有其它处理器想读取这个缓存行（通过总线嗅探机制能立马知道），独占或已修改的缓存行必须先回到"共享"状态。如果是已修改的缓存行，那么还要先把内容回写到内存中。
                举例：
                    问题：线程1修改主存里某个变量的值，线程2要读取这个变量的值，在MESI协议下是怎么操作的？
                    答：线程1改完值并将变量所在的缓存行状态变为Modified后，会通过总线嗅探机制通知线程2将自己本地存储该变量的缓存行状态变为Invalid，线程2再读取自己本地缓存行中该变量的值时，需要从主内存读取，
                       同时线程1需要将自己本地缓存行状态变为Shared，且要将更改后的变量值回写到主内存中。
    c.volatile禁止指令重排序优化：
        1.指令重排序：
            java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。
            指令重排序的意义：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。
            在编译器与CPU处理器中都能执行指令重排优化操作。详见图片
            补充：as-if-serial
                as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。
                为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。
        2.volatile重排序规则：详见图片
            1.第二个操作是volatile写，不管第一个操作是什么都不会重排序。
            2.第一个操作是volatile读，不管第二个操作是什么都不会重排序。
            3.第一个操作是volatile写，第二个操作是volatile读，也不会发生重排序。
            X86处理器不会对读-读、读-写和写-写操作做重排序, 会省略掉这3种操作类型对应的内存屏障。仅会对写-读操作做重排序，所以volatile写-读操作只需要在volatile写后插入StoreLoad屏障。
        3.内存屏障（memory barrier）：
            硬件层提供了一系列的内存屏障 memory barrier/memory fence(Intel的提法)来提供一致性的能力。
            拿X86平台来说，有几种主要的内存屏障：
                1. lfence，是一种Load Barrier读屏障。
                2. sfence，是一种Store Barrier写屏障。
                3. mfence，是一种全能型的屏障，具备lfence和sfence的能力。
                4. Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。它后面可以跟ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG,
                   CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG等指令。
            内存屏障有两个能力：
                1. 阻止屏障两边的指令重排序（保证特定操作的执行顺序）。
                2. 刷新处理器缓存/冲刷处理器缓存（保证某些变量的内存可见性）。
            对Load Barrier来说，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据。
            对Store Barrier来说，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存。
            Lock前缀实现了类似的能力，它先对总线和缓存加锁，然后执行后面的指令，最后释放锁后会把高速缓存中的数据刷新回主内存。在Lock锁住总线的时候，其他CPU的读写请求都会被阻塞，直到锁释放。
            不同硬件实现内存屏障的方式不同，Java内存模型屏蔽了这种底层硬件平台的差异，由JVM来为不同的平台生成相应的机器码。
            为了实现volatile的禁止指令重排序，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。
            JMM内存屏障插入策略：详见图片
                1.在每个volatile写操作的前面插入一个StoreStore屏障。
                2.在每个volatile写操作的后面插入一个StoreLoad屏障。
                3.在每个volatile读操作的后面插入一个LoadLoad屏障。
                4.在每个volatile读操作的后面插入一个LoadStore屏障。
5.CAS（比较并交换-乐观锁机制-锁自旋）：
    CAS可以看做是乐观锁的一种实现方式，Java原子类中的递增操作就通过CAS自旋实现的。
    CAS全称Compare And Swap (比较与交换)，是一种无锁算法。在不使用锁(没有线程被阻塞)的情况下实现多线程之间的变量同步。
    LOCK_IF_MP(%4) "cmpxchgl %1,(%3)" lock  cmpxchgl：汇编指令（CAS操作的汇编指令）。
    unsafe.compareAndSwapInt(this, valueOffset, expect, update);
        上面的方法，有几个重要的参数：
        this，需要改变的对象。
        valueOffset，value变量的内存偏移地址。
        expect，期望更新的值。
        update，要更新的最新值。
        如果原子变量中的value值等于expect，则使用update值更新该值并返回true，否则返回false。
    缺点：
    只能保证对一个变量的原子性操作
    长时间自旋会给CPU带来压力
    ABA问题：
        CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下一时刻比较并替换，那么在这个时间差类会导致数据的变化。比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且
        two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。
        部分乐观锁的实现是通过版本号（version）的方式来解决ABA问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，
        否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。






