1.mysql存储引擎：
  a.InnoDB和MyISAM的比较：
    事务：InnoDB是事务型的，可以使用Commit和Rollback语句。
    并发：MyISAM只支持表级锁，而InnoDB还支持行级锁。
    外键：InnoDB支持外键。
    备份：InnoDB支持在线热备份。
    崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度也更慢。
    其它特性：MyISAM支持压缩表和空间数据索引。
  b.Memory：Memory（也叫 HEAP）堆内存：使用存在内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件。MEMORY类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用
           HASH索引。但是一旦服务关闭，表中的数据就会丢失掉。Memory同时支持散列索引和B树索引，B树索引可以使用部分查询和通配查询，也可以使用<,>和>=等操作符方便数据挖掘，散列索
           引相等的比较快但是对于范围的比较慢很多。
2.mysql索引：索引（Index）是帮助MySQL高效获取数据的数据结构。常见的索引查询算法-顺序查找,二分查找,二叉排序树查找,哈希散列法,分块查找,平衡多路搜索树B树（B-tree）
  a.InnoDB索引实现：InnoDB索引实现采用 B+树 结构，数据文件本身就是索引文件，在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。
                  主键索引（聚簇索引）与非主键索引（二级索引）：
                    主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。
                    非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。
                    如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
                    如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。
                    基于非主键索引的查询需要多扫描一棵索引树（回表）。因此，我们在应用中应该尽量使用主键查询。
                  在使用InnoDB作为数据库存储引擎时最好选择一个与业务无关的自增字段作为主键，因为B+树叶子结点中的记录是按主键顺序存放的，如果选用非自增字段作为主键每次增加或删除记录都要移动前后的记录（内存中就是数据页的分裂以及合并）造成不必要的性能开销。
                  使用自增字段作为主键，每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
  b.MyISAM索引实现：MyISAM索引实现也是采用 B+树 结构，叶节点的data域存放的是数据记录的地址，MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。
                  MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。
  c.覆盖索引：如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。
            由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。
  d.最左前缀原则：B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。例如用户姓名字段加了索引，那么sql语句中的"like '张%'"可以走索引就用了最左前缀原则，可以看到，不只是满足索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。
               这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。有了这个原则我们就可以复用索引了，例如当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。但查询条件里面只有b的话，是无法使用 (a,b) 这个联合索引的
               这时候需要同时维护(a,b)、(b)两个索引。
  e.索引下推：在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。例如InnoDB在(name,age)索引内部判断了age是否等于10，对于不等于10的记录，直接判断并跳过，减少了回表的次数。
3.mysql事务：

4.mysql主从复制（读写分离）：
5.mysql查询性能优化：