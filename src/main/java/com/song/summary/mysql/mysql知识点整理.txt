1.mysql存储引擎：
  a.InnoDB和MyISAM的比较：
    事务：InnoDB是事务型的，可以使用Commit和Rollback语句。
    并发：MyISAM只支持表级锁，而InnoDB还支持行级锁。
    外键：InnoDB支持外键。
    备份：InnoDB支持在线热备份。
    崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度也更慢。
    其它特性：MyISAM支持压缩表和空间数据索引。
  b.Memory：Memory（也叫 HEAP）堆内存：使用存在内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件。MEMORY类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用
           HASH索引。但是一旦服务关闭，表中的数据就会丢失掉。Memory同时支持散列索引和B树索引，B树索引可以使用部分查询和通配查询，也可以使用<,>和>=等操作符方便数据挖掘，散列索
           引相等的比较快但是对于范围的比较慢很多。
2.mysql索引：索引（Index）是帮助MySQL高效获取数据的数据结构。常见的索引查询算法-顺序查找,二分查找,二叉排序树查找,哈希散列法,分块查找,平衡多路搜索树B树（B-tree）
  a.InnoDB索引实现：InnoDB索引实现采用 B+树 结构，数据文件本身就是索引文件，在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。
                  主键索引（聚簇索引）与非主键索引（二级索引）：
                    主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。
                    非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。
                    如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
                    如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。
                    基于非主键索引的查询需要多扫描一棵索引树（回表）。因此，我们在应用中应该尽量使用主键查询。
                  在使用InnoDB作为数据库存储引擎时最好选择一个与业务无关的自增字段作为主键，因为B+树叶子结点中的记录是按主键顺序存放的，如果选用非自增字段作为主键每次增加或删除记录都要移动前后的记录（内存中就是数据页的分裂以及合并）造成不必要的性能开销。
                  使用自增字段作为主键，每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
  b.MyISAM索引实现：MyISAM索引实现也是采用 B+树 结构，叶节点的data域存放的是数据记录的地址，MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。
                  MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。
  c.覆盖索引：如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。
            由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。
  d.最左前缀原则：B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。例如用户姓名字段加了索引，那么sql语句中的"like '张%'"可以走索引就用了最左前缀原则，可以看到，不只是满足索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。
               这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。有了这个原则我们就可以复用索引了，例如当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。但查询条件里面只有b的话，是无法使用 (a,b) 这个联合索引的
               这时候需要同时维护(a,b)、(b)两个索引。
  e.索引下推：在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。例如InnoDB在(name,age)索引内部判断了age是否等于10，对于不等于10的记录，直接判断并跳过，减少了回表的次数。
3.mysql事务：
  a.事务的四大特性（ACID）：Atomicity（原子性），Consistency（一致性），Isolation（隔离性），Durability（持久性）
    原子性，事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行。
    一致性，数据在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。
    隔离性，对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。
    持久性，事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。
        只有满足一致性，事务的结果才是正确的。
        在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
        事务满足持久化是为了能应对数据库崩溃的情况。
  b.事务隔离级别：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable）
    读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
    读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
    可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
    串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。
  c.隔离级别的实现：锁、MVCC（多版本并发控制）
    锁：锁是串行化的主要实现方式，mysql锁主要分共享锁（读锁 in share mode）和排他锁（写锁 for update）。
        共享锁（S Lock），允许事务读一行数据
        排他锁（X Lock），允许事务删除或者更新一行数据
        意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁
        意向排他锁，事务想要获得一张表中某几行的排他锁、
    MVCC（多版本并发控制）：用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。
        MVCC采用无锁化的方式解决了数据库并发情况下读写冲突的问题，提高了数据库并发的性能，主要依靠两个隐式字段（DB_TRX_ID,DB_ROLL_PTR）、undo log、read view实现
        当前读：会给读的行加锁（排他锁），不允许其他事务修改当前行，当前读读的数据都是最新的。
        快照读：像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，
        即MVCC，可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。
        隐式字段：DB_TRX_ID，6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID。
                DB_ROLL_PTR，7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）。
        undo log：insert undo log，代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃。
                update undo log，事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被清除。
        read view：即读视图，是在事务进行快照读时产生的，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)，并把这些ID放到一个列表里，我们把这个列表命名为为m_ids。
                  对于查询时的版本链数据是否看见的判断逻辑：
                      如果被访问版本的DB_TRX_ID属性值小于m_ids列表中最小的事务ID，表明生成该版本的事务在生成read view前已经提交，所以该版本可以被当前事务访问。
                      如果被访问版本的DB_TRX_ID属性值大于m_ids列表中最大的事务ID，表明生成该版本的事务在生成read view后才生成，所以该版本不可以被当前事务访问。
                      如果被访问版本的DB_TRX_ID属性值在m_ids列表中最大的事务ID和最小事务ID之间，那就需要判断一下DB_TRX_ID属性值是不是在m_ids列表中，如果在，
                        说明创建read view时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建read view时生成该版本的事务已经被提交，该版本可以被访问。
        在MySQL中，读提交和可重复读隔离级别的的一个非常大的区别就是它们生成read view的时机不同。在读提交中每次查询都会生成一个实时的read view，做到保证每次提交后的数据是处于当前的可见状态。
        而在可重复读中，在当前事务第一次查询时生成当前的read view会一直沿用到当前事务提交，以此来保证可重复读。
  d.脏读：脏读指的是当前事务可以读取到另外事务未提交（或者已回滚）的数据。
  e.不可重复读：不可重复读指的是同一事务内多次读取同一数据集合，读取到的数据不一样。
  f.幻读：幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。
         1.在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。
         2.事务B的修改结果，被事务A之后的select语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。
  g.丢失更新：一个事务的更新操作会被另一个事务的更新操作所覆盖。
4.mysql主从复制（读写分离）：
      1.MySql主库在事务提交时会把数据变更作为事件记录在二进制日志Binlog中；
      2.主库推送二进制日志文件Binlog中的事件到从库的中继日志Relay Log中，之后从库根据中继日志重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性；
      3.MySql通过三个线程来完成主从库间的数据复制，其中Binlog Dump线程跑在主库上，I/O线程和SQL线程跑在从库上；
      4.当在从库上启动复制时，首先创建I/O线程连接主库，主库随后创建Binlog Dump线程读取数据库事件并发送给I/O线程，I/O线程获取到事件数据后更新到从库的中继日志Relay Log中去，
        之后从库上的SQL线程读取中继日志Relay Log中更新的数据库事件并应用。
5.mysql查询性能优化：
  a.使用explain分析select查询语句：explain用来分析SELECT查询语句，开发人员可以通过分析Explain结果来优化查询语句。
  b.优化数据访问：减少请求的数据量：
                   只返回必要的列：最好不要使用SELECT *语句。
                   只返回必要的行：使用LIMIT语句来限制返回的数据。
                   缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。
                减少服务器端扫描的行数：
                   最有效的方式是使用索引来覆盖查询。
  c.重构查询方式：切分大查询：一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。
                分解大连接查询：
                   将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：
                       （1）让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
                           分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
                       （2）减少锁竞争。
                       （3）在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
                       （4）查询本身效率也可能会有所提升。例如下面的例子中，使用IN()代替连接查询，可以让MySQL按照ID顺序进行查询，这可能比随机的连接要更高效。
6.redo log与binlog区别：
  a.redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。
  b.redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1”。
  c.redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
  (起初MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe（崩溃恢复）的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，
     既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。)